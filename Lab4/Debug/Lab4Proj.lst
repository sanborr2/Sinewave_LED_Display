
Lab4Proj.elf:     file format elf32-littlearm
Lab4Proj.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000081d

Program Header:
    LOAD off    0x00008000 vaddr 0x00000000 paddr 0x00000000 align 2**15
         filesz 0x00000400 memsz 0x00000400 flags r--
    LOAD off    0x00008400 vaddr 0x00000400 paddr 0x00000400 align 2**15
         filesz 0x00000010 memsz 0x00000010 flags r--
    LOAD off    0x00008410 vaddr 0x00000410 paddr 0x00000410 align 2**15
         filesz 0x00000a7c memsz 0x00000a7c flags rwx
    LOAD off    0x00010000 vaddr 0x1fff0000 paddr 0x00000e8c align 2**15
         filesz 0x00000064 memsz 0x00000084 flags rw-
    LOAD off    0x00018000 vaddr 0x20000000 paddr 0x20000000 align 2**15
         filesz 0x00000000 memsz 0x00000800 flags rw-
private flags = 5000002: [Version5 EABI] [has entry point]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 .interrupts   00000400  00000000  00000000  00008000  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .flash_config 00000010  00000400  00000400  00008400  2**0  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00000a6c  00000410  00000410  00008410  2**2  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .ARM          00000008  00000e7c  00000e7c  00008e7c  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  00000e84  00000e84  00008e84  2**2  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  00000e88  00000e88  00008e88  2**2  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000064  1fff0000  00000e8c  00010000  2**2  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000020  1fff0064  00000ef0  00010064  2**2  ALLOC
  8 .heap         00000400  20000000  20000000  00018000  2**0  ALLOC
  9 .stack        00000400  20000400  20000400  00018000  2**0  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  00010064  2**0  CONTENTS, READONLY
 11 .debug_line   000009e5  00000000  00000000  00010094  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00001595  00000000  00000000  00010a79  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000003a5  00000000  00000000  0001200e  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00000100  00000000  00000000  000123b8  2**3  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000000a0  00000000  00000000  000124b8  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  00011409  00000000  00000000  00012558  2**0  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00061935  00000000  00000000  00023961  2**0  CONTENTS, READONLY, DEBUGGING
 18 .comment      00000070  00000000  00000000  00085296  2**0  CONTENTS, READONLY
 19 .debug_frame  000002c8  00000000  00000000  00085308  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    d  .interrupts	00000000 .interrupts
00000400 l    d  .flash_config	00000000 .flash_config
00000410 l    d  .text	00000000 .text
00000e7c l    d  .ARM	00000000 .ARM
00000e84 l    d  .init_array	00000000 .init_array
00000e88 l    d  .fini_array	00000000 .fini_array
1fff0000 l    d  .data	00000000 .data
1fff0064 l    d  .bss	00000000 .bss
20000000 l    d  .heap	00000000 .heap
20000400 l    d  .stack	00000000 .stack
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_macro	00000000 .debug_macro
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 ./Project_Settings/Startup_Code/startup_MK22F51212.o
00000000 l    df *ABS*	00000000 crtstuff.c
00000e64 l     O .text	00000000 __EH_FRAME_BEGIN__
1fff0060 l     O .data	00000000 __JCR_LIST__
00000410 l     F .text	00000000 __do_global_dtors_aux
1fff0064 l       .bss	00000000 completed.7863
00000e88 l     O .fini_array	00000000 __do_global_dtors_aux_fini_array_entry
00000434 l     F .text	00000000 frame_dummy
1fff0068 l       .bss	00000000 object.7868
00000e84 l     O .init_array	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 c:/freescale/kds_3.0.0/toolchain/bin/../lib/gcc/arm-none-eabi/4.8.4/../../../../arm-none-eabi/lib/armv7e-m/fpu/crt0.o
00000000 l    df *ABS*	00000000 ./Sources/Lab4Proj.o
00000000 l       *ABS*	00000000 ZERO
00000001 l       *ABS*	00000000 ONE
00000002 l       *ABS*	00000000 TWO
00000003 l       *ABS*	00000000 THREE
00000005 l       *ABS*	00000000 FIVE
00000006 l       *ABS*	00000000 SIX
00000008 l       *ABS*	00000000 EIGHT
0000000a l       *ABS*	00000000 TEN
00000010 l       *ABS*	00000000 SIXTEEN
00000011 l       *ABS*	00000000 SEVENTEEN
00000012 l       *ABS*	00000000 EIGHTEEN
00000014 l       *ABS*	00000000 TWENTY
00002000 l       *ABS*	00000000 P_TWO_FIVE
00004000 l       *ABS*	00000000 P_FIVE
00006000 l       *ABS*	00000000 P_SEVEN_FIVE
00008000 l       *ABS*	00000000 ONE_ZERO
0000a000 l       *ABS*	00000000 ONE_TWO_FIVE
0000c000 l       *ABS*	00000000 ONE_FIVE
0000e000 l       *ABS*	00000000 ONE_SEVEN_FIVE
00000001 l       *ABS*	00000000 LED0
00000002 l       *ABS*	00000000 LED1
00000004 l       *ABS*	00000000 LED2
00000008 l       *ABS*	00000000 LED3
00000010 l       *ABS*	00000000 LED4
00000020 l       *ABS*	00000000 LED5
00000040 l       *ABS*	00000000 LED6
00000080 l       *ABS*	00000000 LED7
0000003f l       *ABS*	00000000 MAX_INPUT
000f4240 l       *ABS*	00000000 MILLION
00000080 l       *ABS*	00000000 SIXTY_FIFTH_ENTRY
00000028 l       *ABS*	00000000 TC1US
00000030 l       *ABS*	00000000 ASCII_TO_BIN
00001c00 l       *ABS*	00000000 BM_POTRB_C_D_CLKS_ON
40048038 l       *ABS*	00000000 SIM_SCGC5
4004b008 l       *ABS*	00000000 PORTC_PCR2
00000004 l       *ABS*	00000000 PORTx_PCRn_OFFSET
4004a000 l       *ABS*	00000000 PORTB_PCR0
00000040 l       *ABS*	00000000 OFFSET_PORTB_PCR16
00000048 l       *ABS*	00000000 OFFSET_PORTB_PCR18
4004c008 l       *ABS*	00000000 PORTD_PCR2
400ff0c0 l       *ABS*	00000000 GPIOD_PDOR
0000001c l       *ABS*	00000000 BM_LEDOUT_GPIOD_PDDR
400ff040 l       *ABS*	00000000 GPIOB_PDOR
000d0003 l       *ABS*	00000000 BM_LEDOUT_GPIOB_PDDR
400ff080 l       *ABS*	00000000 GPIOC_PDOR
fffffc03 l       *ABS*	00000000 BM_SWIN_GPIOC_PDDR
00000003 l       *ABS*	00000000 BM_SW_PULLUP_EN
00000014 l       *ABS*	00000000 GPIOx_PDDR_OFFSET
00000010 l       *ABS*	00000000 GPIOx_PDIR_OFFSET
00000100 l       *ABS*	00000000 PORT_PCR_MUX_ALT1
0000070c l       .text	00000000 IOShieldIni
00000d2c l       .text	00000000 UserPrompt
00000dbb l       .text	00000000 InvalidNotify
00000dd7 l       .text	00000000 SineTable
000004e8 l       .text	00000000 mainloop
000006fa l       .text	00000000 SwArrayRead
000005aa l       .text	00000000 DisplayWave
0000052c l       .text	00000000 ReadTerminal
00000538 l       .text	00000000 readinputs
00000596 l       .text	00000000 invalidinput
000006e6 l       .text	00000000 IsDigit
000005a4 l       .text	00000000 done
000005cc l       .text	00000000 sineloop
00000626 l       .text	00000000 call_ledwrite
00000682 l       .text	00000000 LEDWrite
00000668 l       .text	00000000 Delayus
0000065a l       .text	00000000 finish
00000676 l       .text	00000000 loop
00000000 l    df *ABS*	00000000 system_MK22F51212.c
00000000 l    df *ABS*	00000000 BasicIO.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 _exit.c
00000000 l    df *ABS*	00000000 impure.c
1fff0000 l     O .data	00000060 impure_data
00000000 l    df *ABS*	00000000 c:/freescale/kds_3.0.0/toolchain/bin/../lib/gcc/arm-none-eabi/4.8.4/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/freescale/kds_3.0.0/toolchain/bin/../lib/gcc/arm-none-eabi/4.8.4/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
1fff0060 l     O .data	00000000 __JCR_END__
00000000 l    df *ABS*	00000000 
00000400 l       *ABS*	00000000 STACK_SIZE
20000400 l       .heap	00000000 __HeapLimit
00000400 l       *ABS*	00000000 HEAP_SIZE
00000e88 l       .init_array	00000000 __init_array_end
00000e84 l       .init_array	00000000 __preinit_array_end
00000e8c l       .fini_array	00000000 __DATA_ROM
2000fc00 l       *ABS*	00000000 __StackLimit
00000e84 l       .init_array	00000000 __init_array_start
00000e84 l       .init_array	00000000 __preinit_array_start
00000848  w    F .text	00000004 Reserved96_IRQHandler
00000848  w    F .text	00000004 Reserved54_IRQHandler
20000000 g       .heap	00000000 __HeapBase
00000848  w    F .text	00000004 DebugMon_Handler
1fff0000 g       .data	00000000 __data_start__
00000848  w    F .text	00000004 I2C0_IRQHandler
00000ba0 g     F .text	000000f4 BIOGetStrg
00000848  w    F .text	00000004 HardFault_Handler
00000848  w    F .text	00000004 Reserved86_IRQHandler
00000848  w    F .text	00000004 Reserved85_IRQHandler
00000848  w    F .text	00000004 SysTick_Handler
00000848  w    F .text	00000004 PendSV_Handler
00000848  w    F .text	00000004 NMI_Handler
00000e84 g       .ARM	00000000 __exidx_end
00000848  w    F .text	00000004 UART0_RX_TX_IRQHandler
00000848  w    F .text	00000004 I2C1_IRQHandler
00000e8c g       .fini_array	00000000 __etext
00000848  w    F .text	00000004 DMA2_IRQHandler
00000848  w    F .text	00000004 Reserved99_IRQHandler
00000848  w    F .text	00000004 PIT0_IRQHandler
00000848  w    F .text	00000004 LLWU_IRQHandler
00000848  w    F .text	00000004 Reserved84_IRQHandler
00000848  w    F .text	00000004 Reserved92_IRQHandler
00000848  w    F .text	00000004 UART2_RX_TX_IRQHandler
00000e84 g       .init_array	00000000 __DTOR_END__
00000b40 g     F .text	00000030 BIOWrite
00000848  w    F .text	00000004 SWI_IRQHandler
00000848  w    F .text	00000004 ADC0_IRQHandler
1fff0064 g       .bss	00000000 __START_BSS
00000848  w    F .text	00000004 UsageFault_Handler
00000848  w    F .text	00000004 I2S0_Tx_IRQHandler
1fff0064 g       .bss	00000000 __bss_start__
00000848  w    F .text	00000004 SPI1_IRQHandler
00000848  w    F .text	00000004 DefaultISR
00000848  w    F .text	00000004 DMA9_IRQHandler
00000848  w    F .text	00000004 DMA14_IRQHandler
00000848  w    F .text	00000004 Reserved82_IRQHandler
00000848  w    F .text	00000004 CMP1_IRQHandler
00000848  w    F .text	00000004 Reserved71_IRQHandler
00000848  w    F .text	00000004 PORTD_IRQHandler
00000848  w    F .text	00000004 PORTB_IRQHandler
00000e7c g       .ARM	00000000 __exidx_start
00000e60 g     O .text	00000004 _global_impure_ptr
00000ccc g     F .text	0000004c __libc_init_array
00000848  w    F .text	00000004 Reserved70_IRQHandler
00000464 g     F .text	00000000 _mainCRTStartup
00000848  w    F .text	00000004 ADC1_IRQHandler
00000e64 g     F .text	00000000 _init
00000848  w    F .text	00000004 PIT2_IRQHandler
00000848  w    F .text	00000004 I2S0_Rx_IRQHandler
00000848  w    F .text	00000004 Reserved53_IRQHandler
00000848  w    F .text	00000004 DMA5_IRQHandler
00000000  w      *UND*	00000000 __libc_fini_array
00000848  w    F .text	00000004 RTC_IRQHandler
00000848  w    F .text	00000004 PDB0_IRQHandler
0000081c  w    F .text	0000002c Reset_Handler
00000848  w    F .text	00000004 FTM1_IRQHandler
00000848  w    F .text	00000004 Reserved61_IRQHandler
00000848  w    F .text	00000004 Reserved95_IRQHandler
00000c94 g     F .text	00000010 BIOOutCRLF
00000848  w    F .text	00000004 PIT3_IRQHandler
00000000  w      *UND*	00000000 __sf_fake_stderr
00000848  w    F .text	00000004 RTC_Seconds_IRQHandler
00000000  w      *UND*	00000000 __deregister_frame_info
00000848  w    F .text	00000004 MCG_IRQHandler
1fff0064 g       .data	00000000 __data_end__
00000e84 g       .init_array	00000000 __CTOR_LIST__
00000848  w    F .text	00000004 UART2_ERR_IRQHandler
00000848  w    F .text	00000004 DMA11_IRQHandler
1fff0084 g       .bss	00000000 __bss_end__
00000a58 g     F .text	0000008c BIOOpen
00000000  w      *UND*	00000000 __call_exitprocs
00000848  w    F .text	00000004 Read_Collision_IRQHandler
00000464 g     F .text	00000000 _start
00000848  w    F .text	00000004 Reserved98_IRQHandler
00000848  w    F .text	00000004 DMA7_IRQHandler
1fff0080 g     O .bss	00000003 UserFrequency
00000000  w      *UND*	00000000 software_init_hook
00000b70 g     F .text	0000002e BIOPutStrg
00000b1c g     F .text	00000022 BIOGetChar
00000848  w    F .text	00000004 Reserved101_IRQHandler
00000848  w    F .text	00000004 USB0_IRQHandler
00000000  w      *UND*	00000000 __sf_fake_stdin
00000848  w    F .text	00000004 WDOG_EWM_IRQHandler
00000d18 g     F .text	00000010 memset
00000848  w    F .text	00000004 MemManage_Handler
00000848  w    F .text	00000004 Reserved90_IRQHandler
00000000 g       .interrupts	00000400 __isr_vector
000004d8 g       .text	00000000 main
00000848  w    F .text	00000004 Reserved83_IRQHandler
00000848  w    F .text	00000004 SVC_Handler
1fff0000 g       .data	00000000 __DATA_RAM
00000000  w      *UND*	00000000 hardware_init_hook
00000848  w    F .text	00000004 DMA13_IRQHandler
20000000 g       .heap	00000000 __end__
00000e84 g       .init_array	00000000 __CTOR_END__
00000848  w    F .text	00000004 DMA3_IRQHandler
00000e84 g       .init_array	00000000 __DTOR_LIST__
1fff0084 g       .bss	00000000 __END_BSS
00000848  w    F .text	00000004 Reserved100_IRQHandler
0000084c g     F .text	0000020c SystemInit
00000848  w    F .text	00000004 RNG_IRQHandler
00000848  w    F .text	00000004 DMA0_IRQHandler
00000848  w    F .text	00000004 Reserved97_IRQHandler
00000e70 g     F .text	00000000 _fini
00000848  w    F .text	00000004 Reserved91_IRQHandler
00000848  w    F .text	00000004 LPUART0_IRQHandler
00000848  w    F .text	00000004 DMA15_IRQHandler
00000848  w    F .text	00000004 DAC0_IRQHandler
00000000  w      *UND*	00000000 atexit
00000848  w    F .text	00000004 Reserved81_IRQHandler
20010000 g       *ABS*	00000000 __StackTop
00000848  w    F .text	00000004 Reserved94_IRQHandler
00000ef0 g       .fini_array	00000000 __DATA_END
00000ae4 g     F .text	00000038 BIORead
00000848  w    F .text	00000004 DMA4_IRQHandler
00000848  w    F .text	00000004 PIT1_IRQHandler
00000848  w    F .text	00000004 UART0_ERR_IRQHandler
20010000 g       *ABS*	00000000 __stack
00000848  w    F .text	00000004 DMA_Error_IRQHandler
00000848  w    F .text	00000004 LVD_LVW_IRQHandler
00000848  w    F .text	00000004 SPI0_IRQHandler
00000848  w    F .text	00000004 FTM0_IRQHandler
00000848  w    F .text	00000004 PORTA_IRQHandler
00000000 g       .interrupts	00000000 __VECTOR_TABLE
00000848  w    F .text	00000004 DAC1_IRQHandler
00000848  w    F .text	00000004 MCM_IRQHandler
00000ca4 g     F .text	00000028 exit
00000848  w    F .text	00000004 DMA12_IRQHandler
00000848  w    F .text	00000004 FTM3_IRQHandler
00000000  w      *UND*	00000000 __sf_fake_stdout
00000848  w    F .text	00000004 PORTE_IRQHandler
00000848  w    F .text	00000004 FTM2_IRQHandler
00000d28 g     F .text	00000002 _exit
00000848  w    F .text	00000004 LPTMR0_IRQHandler
00000848  w    F .text	00000004 BusFault_Handler
00000848  w    F .text	00000004 DMA8_IRQHandler
00000848  w    F .text	00000004 Reserved93_IRQHandler
00000848  w    F .text	00000004 DMA10_IRQHandler
00000848  w    F .text	00000004 UART1_ERR_IRQHandler
00000000  w      *UND*	00000000 _Jv_RegisterClasses
00000848  w    F .text	00000004 UART1_RX_TX_IRQHandler
00000848  w    F .text	00000004 CMP0_IRQHandler
00000000  w      *UND*	00000000 __register_frame_info
00000848  w    F .text	00000004 PORTC_IRQHandler
00000848  w    F .text	00000004 DMA6_IRQHandler
00000848  w    F .text	00000004 FTF_IRQHandler
00000848  w    F .text	00000004 DMA1_IRQHandler



Disassembly of section .text:

00000410 <__do_global_dtors_aux>:
$t():
 410:	b510      	push	{r4, lr}
 412:	4c05      	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
 414:	7823      	ldrb	r3, [r4, #0]
 416:	b933      	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
 418:	4b04      	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
 41a:	b113      	cbz	r3, 422 <__do_global_dtors_aux+0x12>
 41c:	4804      	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
 41e:	f3af 8000 	nop.w
 422:	2301      	movs	r3, #1
 424:	7023      	strb	r3, [r4, #0]
 426:	bd10      	pop	{r4, pc}
$d():
 428:	1fff0064 	.word	0x1fff0064
 42c:	00000000 	.word	0x00000000
 430:	00000e64 	.word	0x00000e64

00000434 <frame_dummy>:
$t():
 434:	b508      	push	{r3, lr}
 436:	4b06      	ldr	r3, [pc, #24]	; (450 <frame_dummy+0x1c>)
 438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
 43a:	4806      	ldr	r0, [pc, #24]	; (454 <frame_dummy+0x20>)
 43c:	4906      	ldr	r1, [pc, #24]	; (458 <frame_dummy+0x24>)
 43e:	f3af 8000 	nop.w
 442:	4806      	ldr	r0, [pc, #24]	; (45c <frame_dummy+0x28>)
 444:	6803      	ldr	r3, [r0, #0]
 446:	b113      	cbz	r3, 44e <frame_dummy+0x1a>
 448:	4b05      	ldr	r3, [pc, #20]	; (460 <frame_dummy+0x2c>)
 44a:	b103      	cbz	r3, 44e <frame_dummy+0x1a>
 44c:	4798      	blx	r3
 44e:	bd08      	pop	{r3, pc}
$d():
 450:	00000000 	.word	0x00000000
 454:	00000e64 	.word	0x00000e64
 458:	1fff0068 	.word	0x1fff0068
 45c:	1fff0060 	.word	0x1fff0060
 460:	00000000 	.word	0x00000000

00000464 <_mainCRTStartup>:
$t():
 464:	4b15      	ldr	r3, [pc, #84]	; (4bc <_mainCRTStartup+0x58>)
 466:	2b00      	cmp	r3, #0
 468:	bf08      	it	eq
 46a:	4b13      	ldreq	r3, [pc, #76]	; (4b8 <_mainCRTStartup+0x54>)
 46c:	469d      	mov	sp, r3
 46e:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
 472:	2100      	movs	r1, #0
 474:	468b      	mov	fp, r1
 476:	460f      	mov	r7, r1
 478:	4813      	ldr	r0, [pc, #76]	; (4c8 <_mainCRTStartup+0x64>)
 47a:	4a14      	ldr	r2, [pc, #80]	; (4cc <_mainCRTStartup+0x68>)
 47c:	1a12      	subs	r2, r2, r0
 47e:	f000 fc4b 	bl	d18 <memset>
 482:	4b0f      	ldr	r3, [pc, #60]	; (4c0 <_mainCRTStartup+0x5c>)
 484:	2b00      	cmp	r3, #0
 486:	d000      	beq.n	48a <_mainCRTStartup+0x26>
 488:	4798      	blx	r3
 48a:	4b0e      	ldr	r3, [pc, #56]	; (4c4 <_mainCRTStartup+0x60>)
 48c:	2b00      	cmp	r3, #0
 48e:	d000      	beq.n	492 <_mainCRTStartup+0x2e>
 490:	4798      	blx	r3
 492:	2000      	movs	r0, #0
 494:	2100      	movs	r1, #0
 496:	0004      	movs	r4, r0
 498:	000d      	movs	r5, r1
 49a:	480d      	ldr	r0, [pc, #52]	; (4d0 <_mainCRTStartup+0x6c>)
 49c:	2800      	cmp	r0, #0
 49e:	d002      	beq.n	4a6 <_mainCRTStartup+0x42>
 4a0:	480c      	ldr	r0, [pc, #48]	; (4d4 <_mainCRTStartup+0x70>)
 4a2:	f3af 8000 	nop.w
 4a6:	f000 fc11 	bl	ccc <__libc_init_array>
 4aa:	0020      	movs	r0, r4
 4ac:	0029      	movs	r1, r5
 4ae:	f000 f813 	bl	4d8 <main>
 4b2:	f000 fbf7 	bl	ca4 <exit>
 4b6:	bf00      	nop
$d():
 4b8:	00080000 	.word	0x00080000
 4bc:	20010000 	.word	0x20010000
	...
 4c8:	1fff0064 	.word	0x1fff0064
 4cc:	1fff0084 	.word	0x1fff0084
	...

000004d8 <main>:
$t():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:103
/******************************************************************************
 * main program code
 *****************************************************************************/
                .section .text
main:
				bl IOShieldIni          /*  Initialize the FDRM Board for K22F */
 4d8:	f000 f918 	bl	70c <IOShieldIni>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:104
				bl BIOOpen              /*  Initialize serial port  */
 4dc:	f000 fabc 	bl	a58 <BIOOpen>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:106

				ldr r6, =UserPrompt
 4e0:	4eac      	ldr	r6, [pc, #688]	; (794 <IOShieldIni+0x88>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:107
				ldr r5, =InvalidNotify
 4e2:	4dad      	ldr	r5, [pc, #692]	; (798 <IOShieldIni+0x8c>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:108
				ldr r8, =SineTable
 4e4:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 79c <IOShieldIni+0x90>

000004e8 <mainloop>:
mainloop():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:112

mainloop:
				/*		        Check Status of Switches	       */
				bl SwArrayRead
 4e8:	f000 f907 	bl	6fa <SwArrayRead>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:113
				cmp r0, #ZERO
 4ec:	2800      	cmp	r0, #0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:114
				mov r7, r0                 /*Preserve LastSwStatus in r7*/
 4ee:	4607      	mov	r7, r0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:118

				/* If Switch input is nonzero, ignore terminal*/

				mrs r4, apsr              /* Preserve status flags against both possible calls*/
 4f0:	f3ef 8400 	mrs	r4, CPSR
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:119
				ittt ne
 4f4:	bf1e      	ittt	ne
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:120
				movne r1, r7
 4f6:	4639      	movne	r1, r7
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:121
				movne r2, r8
 4f8:	4642      	movne	r2, r8
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:122
				blne DisplayWave            /* Pass Frequency from Switches, LastSwStatus, and SineTable pointer*/
 4fa:	f000 f856 	blne	5aa <DisplayWave>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:123
				msr apsr_nzcvq, r4
 4fe:	f384 8800 	msr	CPSR_f, r4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:127


				/* Otherwise continuously read from the terminal until given a valid frequency*/
				mrs r4, apsr
 502:	f3ef 8400 	mrs	r4, CPSR
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:128
				itttt eq
 506:	bf01      	itttt	eq
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:129
				ldreq r0, =UserFrequency
 508:	48a5      	ldreq	r0, [pc, #660]	; (7a0 <IOShieldIni+0x94>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:130
				moveq r1, r6
 50a:	4631      	moveq	r1, r6
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:131
				moveq r2, r5
 50c:	462a      	moveq	r2, r5
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:132
				bleq ReadTerminal
 50e:	f000 f80d 	bleq	52c <ReadTerminal>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:133
				msr apsr_nzcvq, r4
 512:	f384 8800 	msr	CPSR_f, r4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:135

				mrs r4, apsr
 516:	f3ef 8400 	mrs	r4, CPSR
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:136
				ittt eq
 51a:	bf02      	ittt	eq
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:137
				moveq r1, r7
 51c:	4639      	moveq	r1, r7
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:138
				moveq r2, r8
 51e:	4642      	moveq	r2, r8
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:139
				bleq DisplayWave            /* Pass Frequency from Terminal, LastSwStatus, and SineTable pointer*/
 520:	f000 f843 	bleq	5aa <DisplayWave>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:140
				msr apsr_nzcvq, r4
 524:	f384 8800 	msr	CPSR_f, r4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:142

				b mainloop
 528:	f7ff bfde 	b.w	4e8 <mainloop>

0000052c <ReadTerminal>:
ReadTerminal():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:167
 *Assuming: Fsys = 200MHz
 *
 * Robert Sanborn, 3/13/18
 *************************************************************************************************/
ReadTerminal:
			 	push {lr}
 52c:	b500      	push	{lr}
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:168
				push {r4, r5, r6, r7, r8, r9}
 52e:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:170

				mov r7, r0                      /* Preserve UserFrequency*/
 532:	4607      	mov	r7, r0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:171
				mov r8, r1					    /* UserPrompt*/
 534:	4688      	mov	r8, r1
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:172
				mov r9, r2					    /* InvalidNotify*/
 536:	4691      	mov	r9, r2

00000538 <readinputs>:
readinputs():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:174

readinputs:     bl BIOOutCRLF
 538:	f000 fbac 	bl	c94 <BIOOutCRLF>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:177

				/*       If Switches are all off, begin reading the Terminal           */
				mov r0, r8            /* Output question to user on screen*/
 53c:	4640      	mov	r0, r8
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:178
				bl BIOPutStrg
 53e:	f000 fb17 	bl	b70 <BIOPutStrg>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:181


				ldr r0, =THREE
 542:	4898      	ldr	r0, [pc, #608]	; (7a4 <IOShieldIni+0x98>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:182
				mov r1, r7
 544:	4639      	mov	r1, r7
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:183
				bl BIOGetStrg
 546:	f000 fb2b 	bl	ba0 <BIOGetStrg>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:185

				cmp r0, #ZERO                   /* If user typed an input too long send invalid notification */
 54a:	2800      	cmp	r0, #0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:186
				bne invalidinput
 54c:	f040 8023 	bne.w	596 <invalidinput>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:190


				/*   Get first digit  */
				ldrb r5, [r7]
 550:	783d      	ldrb	r5, [r7, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:191
				mov r0, r5
 552:	4628      	mov	r0, r5
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:192
				bl IsDigit
 554:	f000 f8c7 	bl	6e6 <IsDigit>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:194

				cmp r0, #ZERO
 558:	2800      	cmp	r0, #0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:195
				bne invalidinput
 55a:	f040 801c 	bne.w	596 <invalidinput>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:197

				sub r5, #ASCII_TO_BIN
 55e:	f1a5 0530 	sub.w	r5, r5, #48	; 0x30
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:200

				/*   Get possible second digit  */
				ldrb r4, [r7, #ONE]
 562:	787c      	ldrb	r4, [r7, #1]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:201
				mov r0, r4
 564:	4620      	mov	r0, r4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:202
				bl IsDigit
 566:	f000 f8be 	bl	6e6 <IsDigit>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:204

				cmp r4, #ZERO                   /* if user specifies one digit, calculate frequency using one digit*/
 56a:	2c00      	cmp	r4, #0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:205
				ittte eq
 56c:	bf03      	ittte	eq
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:206
				ldreq r0, =ZERO
 56e:	488e      	ldreq	r0, [pc, #568]	; (7a8 <IOShieldIni+0x9c>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:207
				ldreq r6, =ONE
 570:	4e8e      	ldreq	r6, [pc, #568]	; (7ac <IOShieldIni+0xa0>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:208
				ldreq r4, ='0
 572:	4c8f      	ldreq	r4, [pc, #572]	; (7b0 <IOShieldIni+0xa4>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:209
				ldrne r6, =TEN
 574:	4e8f      	ldrne	r6, [pc, #572]	; (7b4 <IOShieldIni+0xa8>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:211

				sub r4, #ASCII_TO_BIN           /* Use mask value to convert to Bin  */
 576:	f1a4 0430 	sub.w	r4, r4, #48	; 0x30
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:213

				cmp r0, #ZERO
 57a:	2800      	cmp	r0, #0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:214
				bne invalidinput                /* Handle invalid input */
 57c:	f040 800b 	bne.w	596 <invalidinput>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:218


				/* Calculate two digit decimal number, Frequency */
				mul r5, r6
 580:	fb06 f505 	mul.w	r5, r6, r5
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:219
				add r0, r5, r4
 584:	eb05 0004 	add.w	r0, r5, r4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:222

 				/* If user input greater than 63, notify them input is invalid */
				cmp r0, #MAX_INPUT
 588:	283f      	cmp	r0, #63	; 0x3f
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:223
				bgt invalidinput
 58a:	f300 8004 	bgt.w	596 <invalidinput>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:226

				/* Check to make certain input is not zero*/
				cmp r0, #ZERO
 58e:	2800      	cmp	r0, #0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:227
				it ne                            /* If Everything Checks out begin display process */
 590:	bf18      	it	ne
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:228
				bne done
 592:	f000 b807 	bne.w	5a4 <done>

00000596 <invalidinput>:
invalidinput():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:232

				/*            Handle Invalid Inputs        */
invalidinput:
				bl BIOOutCRLF
 596:	f000 fb7d 	bl	c94 <BIOOutCRLF>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:233
				mov r0, r9
 59a:	4648      	mov	r0, r9
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:234
				bl BIOPutStrg
 59c:	f000 fae8 	bl	b70 <BIOPutStrg>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:236

				b readinputs
 5a0:	f7ff bfca 	b.w	538 <readinputs>

000005a4 <done>:
done():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:239

done:
				pop {r4, r5, r6, r7, r8, r9}
 5a4:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:240
				pop {pc}
 5a8:	bd00      	pop	{pc}

000005aa <DisplayWave>:
DisplayWave():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:262
 *Assuming: Fsys = 200MHz
 *
 * Robert Sanborn, 3/9/18
 ***********************************************************************************************/
DisplayWave:
		        push {lr}
 5aa:	b500      	push	{lr}
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:263
				push {r4, r5, r6, r7}
 5ac:	b4f0      	push	{r4, r5, r6, r7}
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:266

				/* Make copies of LastSwStatus and SineTable*/
				mov r7, r1
 5ae:	460f      	mov	r7, r1
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:267
				mov r5, r2
 5b0:	4615      	mov	r5, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:271

				/*			Begin Process of creating Sine Wave                      */

				USAT r4, #SIX, r0               /* Saturate frequency to 63 Hz if not already done so for sanity's sake*/
 5b2:	f380 0406 	usat	r4, #6, r0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:272
				lsl r4, #SIX                    /* (freq x 64) */
 5b6:	ea4f 1484 	mov.w	r4, r4, lsl #6
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:273
			    ldr r3, =MILLION
 5ba:	4b7f      	ldr	r3, [pc, #508]	; (7b8 <IOShieldIni+0xac>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:274
			    udiv r0, r3, r4                 /* Calculate Period, us, as 10^6/(64*freq), */
 5bc:	fbb3 f0f4 	udiv	r0, r3, r4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:277
			    					            /* result is in micro seconds*/

			    mov r6, r0                      /* Make copy of us and SineTable */
 5c0:	4606      	mov	r6, r0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:278
				mov r4, r5
 5c2:	462c      	mov	r4, r5
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:280

				cmp r1, #ZERO                   /* If Switch inputs are still off output carriage return on terminal*/
 5c4:	2900      	cmp	r1, #0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:281
				it eq
 5c6:	bf08      	it	eq
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:282
			    bleq BIOOutCRLF
 5c8:	f000 fb64 	bleq	c94 <BIOOutCRLF>

000005cc <sineloop>:
sineloop():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:285


sineloop:		ldrh r3, [r4], #TWO
 5cc:	f834 3b02 	ldrh.w	r3, [r4], #2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:289

                /* Check what range the value is in, pass the correct LBits value to LEDWrite */

				ldr r2, =P_TWO_FIVE             /* Is value in range of [0.00 : 0.25)? */
 5d0:	4a7a      	ldr	r2, [pc, #488]	; (7bc <IOShieldIni+0xb0>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:290
				cmp r3, r2
 5d2:	4293      	cmp	r3, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:291
				itt lt
 5d4:	bfbc      	itt	lt
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:292
				ldrlt r0, =LED0
 5d6:	4875      	ldrlt	r0, [pc, #468]	; (7ac <IOShieldIni+0xa0>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:293
				blt call_ledwrite
 5d8:	f000 b825 	blt.w	626 <call_ledwrite>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:295

				ldr r2, =P_FIVE                 /* Is value in range of [0.25 : 0.50)? */
 5dc:	4a78      	ldr	r2, [pc, #480]	; (7c0 <IOShieldIni+0xb4>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:296
				cmp r3, r2
 5de:	4293      	cmp	r3, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:297
				itt lt
 5e0:	bfbc      	itt	lt
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:298
				ldrlt r0, =LED1
 5e2:	4878      	ldrlt	r0, [pc, #480]	; (7c4 <IOShieldIni+0xb8>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:299
				blt call_ledwrite
 5e4:	f000 b81f 	blt.w	626 <call_ledwrite>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:301

				ldr r2, =P_SEVEN_FIVE           /* Is value in range of [0.50 : 0.75)? */
 5e8:	4a77      	ldr	r2, [pc, #476]	; (7c8 <IOShieldIni+0xbc>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:302
				cmp r3, r2
 5ea:	4293      	cmp	r3, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:303
				itt lt
 5ec:	bfbc      	itt	lt
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:304
				ldrlt r0, =LED2
 5ee:	4877      	ldrlt	r0, [pc, #476]	; (7cc <IOShieldIni+0xc0>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:305
				blt call_ledwrite
 5f0:	f000 b819 	blt.w	626 <call_ledwrite>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:307

				ldr r2, =ONE_ZERO               /* Is value in range of [0.75 : 1.00)? */
 5f4:	4a76      	ldr	r2, [pc, #472]	; (7d0 <IOShieldIni+0xc4>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:308
				cmp r3, r2
 5f6:	4293      	cmp	r3, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:309
				itt lt
 5f8:	bfbc      	itt	lt
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:310
				ldrlt r0, =LED3
 5fa:	4876      	ldrlt	r0, [pc, #472]	; (7d4 <IOShieldIni+0xc8>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:311
				blt call_ledwrite
 5fc:	f000 b813 	blt.w	626 <call_ledwrite>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:313

				ldr r2, =ONE_TWO_FIVE           /* Is value in range of [1.00 : 1.25)? */
 600:	4a75      	ldr	r2, [pc, #468]	; (7d8 <IOShieldIni+0xcc>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:314
				cmp r3, r2
 602:	4293      	cmp	r3, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:315
				itt lt
 604:	bfbc      	itt	lt
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:316
				ldrlt r0, =LED4
 606:	4875      	ldrlt	r0, [pc, #468]	; (7dc <IOShieldIni+0xd0>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:317
				blt call_ledwrite
 608:	f000 b80d 	blt.w	626 <call_ledwrite>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:319

				ldr r2, =ONE_FIVE               /* Is value in range of [1.25 : 1.50)? */
 60c:	4a74      	ldr	r2, [pc, #464]	; (7e0 <IOShieldIni+0xd4>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:320
				cmp r3, r2
 60e:	4293      	cmp	r3, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:321
				itt lt
 610:	bfbc      	itt	lt
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:322
				ldrlt r0, =LED5
 612:	4874      	ldrlt	r0, [pc, #464]	; (7e4 <IOShieldIni+0xd8>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:323
				blt call_ledwrite
 614:	f000 b807 	blt.w	626 <call_ledwrite>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:325

				ldr r2, =ONE_SEVEN_FIVE         /* Is value in range of [1.50 : 1.75)? */
 618:	4a73      	ldr	r2, [pc, #460]	; (7e8 <IOShieldIni+0xdc>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:326
				cmp r3, r2
 61a:	4293      	cmp	r3, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:327
				itt lt
 61c:	bfbc      	itt	lt
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:328
				ldrlt r0, =LED6
 61e:	4873      	ldrlt	r0, [pc, #460]	; (7ec <IOShieldIni+0xe0>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:329
				blt call_ledwrite
 620:	f000 b801 	blt.w	626 <call_ledwrite>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:331

				ldr r0, =LED7                   /* Assume at this point that value of sine table */
 624:	4872      	ldr	r0, [pc, #456]	; (7f0 <IOShieldIni+0xe4>)

00000626 <call_ledwrite>:
call_ledwrite():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:334
											    /*  is in range of [1.75 : 2.00] */

call_ledwrite:  bl LEDWrite
 626:	f000 f82c 	bl	682 <LEDWrite>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:337

				/* Create Delay time to wait for certian period of time */
				mov r0, r6
 62a:	4630      	mov	r0, r6
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:338
				bl Delayus
 62c:	f000 f81c 	bl	668 <Delayus>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:342

				/* Check if all entries have been iterated over */

				mov r1, r5                     /* Use Bitmask of value 0x80 (128) to obtain address  */
 630:	4629      	mov	r1, r5
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:343
				ldr r2, =SIXTY_FIFTH_ENTRY	   /*  of "sixty-fifth" entry, or the first address */
 632:	4a6f      	ldr	r2, [pc, #444]	; (7f0 <IOShieldIni+0xe4>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:344
				add r1, r2  				   /*  just after the sine table*/
 634:	4411      	add	r1, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:346

				cmp r4, r1
 636:	428c      	cmp	r4, r1
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:347
				it eq
 638:	bf08      	it	eq
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:348
				moveq r4, r5
 63a:	462c      	moveq	r4, r5
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:351

				/* Check status of switches for change */
				bl SwArrayRead
 63c:	f000 f85d 	bl	6fa <SwArrayRead>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:352
				cmp r0, r7
 640:	42b8      	cmp	r0, r7
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:353
				bne finish
 642:	f040 800a 	bne.w	65a <finish>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:355

				cmp r0, #ZERO
 646:	2800      	cmp	r0, #0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:356
				bne sineloop
 648:	f47f afc0 	bne.w	5cc <sineloop>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:359

				/* Check r0 for q value as sign user has ended sine wave at given frequency if frequency is zero */
				bl BIORead
 64c:	f000 fa4a 	bl	ae4 <BIORead>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:360
				cmp r0, 'q
 650:	2871      	cmp	r0, #113	; 0x71
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:361
				beq finish
 652:	f000 8002 	beq.w	65a <finish>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:363

				b sineloop
 656:	f7ff bfb9 	b.w	5cc <sineloop>

0000065a <finish>:
finish():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:366

 /*             End Sinewave Display           */
finish:	        ldr r0, =ZERO
 65a:	4853      	ldr	r0, [pc, #332]	; (7a8 <IOShieldIni+0x9c>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:367
				bl LEDWrite
 65c:	f000 f811 	bl	682 <LEDWrite>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:369

			    bl BIORead             /* Clear UART buffer with BIORead */
 660:	f000 fa40 	bl	ae4 <BIORead>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:371

				pop {r4, r5, r6, r7}
 664:	bcf0      	pop	{r4, r5, r6, r7}
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:372
				pop {pc}
 666:	bd00      	pop	{pc}

00000668 <Delayus>:
Delayus():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:388
 *      MCU: K22F
 *Assumming: Fsys = 200MHz
 *
 * Robert Sanborn, 3/9/18
 **********************************************************************************/
Delayus:        push {lr}
 668:	b500      	push	{lr}
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:389
				mov r1, #TC1US
 66a:	f04f 0128 	mov.w	r1, #40	; 0x28
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:390
				mul r2, r0, r1
 66e:	fb00 f201 	mul.w	r2, r0, r1
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:391
				sub r2, #TWO
 672:	f1a2 0202 	sub.w	r2, r2, #2

00000676 <loop>:
loop():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:394

/* Delay lasts for "us" microseconds */
loop:           subs r2, #1
 676:	3a01      	subs	r2, #1
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:395
				bne loop
 678:	f47f affd 	bne.w	676 <loop>
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:397

				sub r1, r1
 67c:	eba1 0101 	sub.w	r1, r1, r1
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:398
				pop {pc}
 680:	bd00      	pop	{pc}

00000682 <LEDWrite>:
LEDWrite():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:410
 * Returns: none
 *     MCU: K22F, using IO FDRM Shield
 *
 * Robert Sanborn, 3/9/18
 *****************************************************************************/
LEDWrite:       push {lr}
 682:	b500      	push	{lr}
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:412

                sub r1, r1
 684:	eba1 0101 	sub.w	r1, r1, r1
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:413
                sub r2, r2
 688:	eba2 0202 	sub.w	r2, r2, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:416

                /* Manipulate LBits into format for GPIOB_PDOR and GPIOD_PDOR */
                lsl r0, #TWO
 68c:	ea4f 0080 	mov.w	r0, r0, lsl #2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:417
                bfi r1, r0, #ZERO, #FIVE               /* Extract bits for updating LED[2:0] into r1*/
 690:	f360 0104 	bfi	r1, r0, #0, #5
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:419

                lsr r0, #FIVE
 694:	ea4f 1050 	mov.w	r0, r0, lsr #5
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:420
                bfi r1, r0, #ZERO, #TWO                /* Extract bits for updating LED[7:3] and  place into r1*/
 698:	f360 0101 	bfi	r1, r0, #0, #2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:421
                lsr r0, #TWO
 69c:	ea4f 0090 	mov.w	r0, r0, lsr #2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:422
                lsl r0, #SIXTEEN
 6a0:	ea4f 4000 	mov.w	r0, r0, lsl #16
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:423
                bfi r2, r0, #ZERO, #SEVENTEEN
 6a4:	f360 0210 	bfi	r2, r0, #0, #17
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:424
                lsl r0, #ONE
 6a8:	ea4f 0040 	mov.w	r0, r0, lsl #1
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:425
                orr r0, r2
 6ac:	ea40 0002 	orr.w	r0, r0, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:426
                orr r0, r1                             /* Place bits for all  in r0 */
 6b0:	ea40 0001 	orr.w	r0, r0, r1
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:429

                /* Extract bits for correct GPIOx_PDOR to update correct LED(s) */
                mvn r0, r0                             /* Make value Active LOW to be used to update LED */
 6b4:	ea6f 0000 	mvn.w	r0, r0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:431

                ldr r2, =GPIOD_PDOR                    /* Update status of LED[2:0] on IO FDRM Shield */
 6b8:	4a4e      	ldr	r2, [pc, #312]	; (7f4 <IOShieldIni+0xe8>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:432
                ldr r3, [r2]
 6ba:	6813      	ldr	r3, [r2, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:433
                mov r1, r3
 6bc:	4619      	mov	r1, r3
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:434
                bfi r1, r0, #ZERO, #FIVE
 6be:	f360 0104 	bfi	r1, r0, #0, #5
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:435
                bfi r1, r3, #ZERO, #TWO
 6c2:	f363 0101 	bfi	r1, r3, #0, #2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:436
                str r1, [r2]
 6c6:	6011      	str	r1, [r2, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:438

                ldr r2, =GPIOB_PDOR                    /* Update status of LED[7:3] on IO FDRM Shield*/
 6c8:	4a4b      	ldr	r2, [pc, #300]	; (7f8 <IOShieldIni+0xec>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:439
                ldr r3, [r2]
 6ca:	6813      	ldr	r3, [r2, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:440
                mov r1, r3
 6cc:	4619      	mov	r1, r3
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:441
                bfi r1, r0, #ZERO, #TWENTY
 6ce:	f360 0113 	bfi	r1, r0, #0, #20
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:442
                bfi r1, r3, #ZERO, #EIGHTEEN
 6d2:	f363 0111 	bfi	r1, r3, #0, #18
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:443
                bfi r1, r0, #ZERO, #SEVENTEEN
 6d6:	f360 0110 	bfi	r1, r0, #0, #17
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:444
                bfi r1, r3, #ZERO, #SIXTEEN
 6da:	f363 010f 	bfi	r1, r3, #0, #16
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:445
                bfi r1, r0, #ZERO, #TWO
 6de:	f360 0101 	bfi	r1, r0, #0, #2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:446
                str r1, [r2]
 6e2:	6011      	str	r1, [r2, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:448

                pop {pc}                               /* Return */
 6e4:	bd00      	pop	{pc}

000006e6 <IsDigit>:
IsDigit():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:461
 * 			1 -> if not valid decimal digit
 *     MCU: K22F
 *
 * Robert Sanborn, 3/9/18
 **********************************************************************************/
IsDigit:        push {lr}
 6e6:	b500      	push	{lr}
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:462
				ldr r1, =0
 6e8:	492f      	ldr	r1, [pc, #188]	; (7a8 <IOShieldIni+0x9c>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:464

				cmp r0, #'0       /* If INT8C is not an ascii number*/
 6ea:	2830      	cmp	r0, #48	; 0x30
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:465
				it lt             /*  return a 1 in r0 */
 6ec:	bfb8      	it	lt
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:466
				ldrlt r1, =1
 6ee:	492f      	ldrlt	r1, [pc, #188]	; (7ac <IOShieldIni+0xa0>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:468

				cmp r0, #'9
 6f0:	2839      	cmp	r0, #57	; 0x39
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:469
				it gt
 6f2:	bfc8      	it	gt
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:470
				ldrgt r1, =1
 6f4:	492d      	ldrgt	r1, [pc, #180]	; (7ac <IOShieldIni+0xa0>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:472

				mov r0, r1
 6f6:	4608      	mov	r0, r1
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:473
				pop {pc}
 6f8:	bd00      	pop	{pc}

000006fa <SwArrayRead>:
SwArrayRead():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:484
 * Returns: 8-bit unsigned integer, SwStatus, representing status of switches[7:0]
 *     MCU: K22F, using IO FDRM Shield
 *
 * Robert Sanborn, 3/9/18
 **********************************************************************************/
SwArrayRead:    push {lr}
 6fa:	b500      	push	{lr}
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:486

                ldr r3, =GPIOC_PDOR
 6fc:	4b3f      	ldr	r3, [pc, #252]	; (7fc <IOShieldIni+0xf0>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:487
                ldr r2, [r3, #GPIOx_PDIR_OFFSET]         /* Read status of Switches on GPIOC_PDIR */
 6fe:	691a      	ldr	r2, [r3, #16]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:488
                lsr r2, #TWO
 700:	ea4f 0292 	mov.w	r2, r2, lsr #2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:489
                ldr r0, =ZERO
 704:	4828      	ldr	r0, [pc, #160]	; (7a8 <IOShieldIni+0x9c>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:490
                bfi r0, r2, #ZERO, #EIGHT                /* Save 8 bits representing the status of 8 switches  */
 706:	f362 0007 	bfi	r0, r2, #0, #8
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:492

                pop {pc}
 70a:	bd00      	pop	{pc}

0000070c <IOShieldIni>:
IOShieldIni():
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:504
 * Returns: None
 *     MCU: K22F, using IO FDRM Shield
 *
 * Robert Sanborn, 3/9/18
 *****************************************************************************/
IOShieldIni:    push {lr}
 70c:	b500      	push	{lr}
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:507

                /* Initialize Clock Gate for Ports B, C, and D */
				ldr r0, =SIM_SCGC5
 70e:	483c      	ldr	r0, [pc, #240]	; (800 <IOShieldIni+0xf4>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:508
                ldr r2, [r0]
 710:	6802      	ldr	r2, [r0, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:509
                orr r2, #BM_POTRB_C_D_CLKS_ON
 712:	f442 52e0 	orr.w	r2, r2, #7168	; 0x1c00
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:510
                str r2, [r0]
 716:	6002      	str	r2, [r0, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:515

                /*                Initialize Ports for LED and Switches                   */

				/* Initialize PORT D Data Direction Register for LED[2:0] to make Outputs */
                ldr r1, =GPIOD_PDOR
 718:	4936      	ldr	r1, [pc, #216]	; (7f4 <IOShieldIni+0xe8>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:516
                ldr r3, [r1, #GPIOx_PDDR_OFFSET]
 71a:	694b      	ldr	r3, [r1, #20]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:517
                orr r3, #BM_LEDOUT_GPIOD_PDDR        /* Bit Mask for initializing LED[2:0]*/
 71c:	f043 031c 	orr.w	r3, r3, #28
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:518
                str r3, [r1, #GPIOx_PDDR_OFFSET]
 720:	614b      	str	r3, [r1, #20]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:521

                /* Initialize PORT B Data Direction Register for LED[7:3] to make Outputs*/
                ldr r1, =GPIOB_PDOR
 722:	4935      	ldr	r1, [pc, #212]	; (7f8 <IOShieldIni+0xec>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:522
                ldr r3, [r1, #GPIOx_PDDR_OFFSET]
 724:	694b      	ldr	r3, [r1, #20]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:523
                ldr r2, =BM_LEDOUT_GPIOB_PDDR        /* Bit Mask for initializing LED[7:3] to make Outputs*/
 726:	4a37      	ldr	r2, [pc, #220]	; (804 <IOShieldIni+0xf8>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:524
                orr r3, r2
 728:	ea43 0302 	orr.w	r3, r3, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:525
                str r3, [r1, #GPIOx_PDDR_OFFSET]
 72c:	614b      	str	r3, [r1, #20]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:529


                /* Initialize PORT C Data Direction register for Switches to become Inputs*/
                ldr r1, =GPIOC_PDOR
 72e:	4933      	ldr	r1, [pc, #204]	; (7fc <IOShieldIni+0xf0>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:530
                ldr r3, [r1, #GPIOx_PDDR_OFFSET]
 730:	694b      	ldr	r3, [r1, #20]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:531
                ldr r2, =BM_SWIN_GPIOC_PDDR
 732:	4a35      	ldr	r2, [pc, #212]	; (808 <IOShieldIni+0xfc>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:532
                and r3, r2                               /* Bit Mask for initializing SWITCH[7:0]*/
 734:	ea03 0302 	and.w	r3, r3, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:533
                str r3, [r1, #GPIOx_PDDR_OFFSET]
 738:	614b      	str	r3, [r1, #20]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:538

				/*                  Initialize LEDs as all off                             */

				/* Initialize the GPIOD_PDOR for LED[2:0] to off state */
                ldr r1, =GPIOD_PDOR
 73a:	492e      	ldr	r1, [pc, #184]	; (7f4 <IOShieldIni+0xe8>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:539
                ldr r3, [r1]
 73c:	680b      	ldr	r3, [r1, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:540
                orr r3, #BM_LEDOUT_GPIOD_PDDR        /* Reuse GPIOD_PDDR mask to initailize LED[2:0] as off */
 73e:	f043 031c 	orr.w	r3, r3, #28
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:541
                str r3, [r1]
 742:	600b      	str	r3, [r1, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:544

                /* Initialize the GPIOB_PDDR for LED[7:3] to off state */
                ldr r1, =GPIOB_PDOR
 744:	492c      	ldr	r1, [pc, #176]	; (7f8 <IOShieldIni+0xec>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:545
                ldr r3, [r1]
 746:	680b      	ldr	r3, [r1, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:546
                ldr r2, =BM_LEDOUT_GPIOB_PDDR
 748:	4a2e      	ldr	r2, [pc, #184]	; (804 <IOShieldIni+0xf8>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:547
                orr r3, r2                           /* Use Mask for GPIOB_PDDR for PORTB to */
 74a:	ea43 0302 	orr.w	r3, r3, r2
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:548
                str r3, [r1]
 74e:	600b      	str	r3, [r1, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:553

				/*              Initialize PCRs for LEDs and Switches                   */

                /* Initialize Pin Control Registers for LED[2:0] on PORTD */
                ldr r0, =PORTD_PCR2
 750:	482e      	ldr	r0, [pc, #184]	; (80c <IOShieldIni+0x100>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:554
                ldr r1, =PORT_PCR_MUX_ALT1
 752:	492f      	ldr	r1, [pc, #188]	; (810 <IOShieldIni+0x104>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:555
                str r1, [r0], #PORTx_PCRn_OFFSET
 754:	f840 1b04 	str.w	r1, [r0], #4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:556
                str r1, [r0], #PORTx_PCRn_OFFSET
 758:	f840 1b04 	str.w	r1, [r0], #4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:557
                str r1, [r0]
 75c:	6001      	str	r1, [r0, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:560

                /* Initialize Pin Control Registers for LED[7:3] on PORTD */
                ldr r0, =PORTB_PCR0
 75e:	482d      	ldr	r0, [pc, #180]	; (814 <IOShieldIni+0x108>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:561
                str r1, [r0]                             /* r1 still has PORT_PCR_MUX_ALT1*/
 760:	6001      	str	r1, [r0, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:562
                str r1, [r0, #PORTx_PCRn_OFFSET]
 762:	6041      	str	r1, [r0, #4]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:563
                str r1, [r0, #OFFSET_PORTB_PCR16]
 764:	6401      	str	r1, [r0, #64]	; 0x40
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:564
                str r1, [r0, #OFFSET_PORTB_PCR18]!
 766:	f840 1f48 	str.w	r1, [r0, #72]!
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:565
                str r1, [r0, #PORTx_PCRn_OFFSET]
 76a:	6041      	str	r1, [r0, #4]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:568

  				/* Initialize Pin Control Registers for SWITCH[7:0] on PORTC    */
                ldr r0, =PORTC_PCR2
 76c:	482a      	ldr	r0, [pc, #168]	; (818 <IOShieldIni+0x10c>)
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:569
                orr r1, #BM_SW_PULLUP_EN                  /* r1 now MUX Enable OR'ed with Pullup Resistor Enable Code for Switches*/
 76e:	f041 0103 	orr.w	r1, r1, #3
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:570
                str r1, [r0], #PORTx_PCRn_OFFSET
 772:	f840 1b04 	str.w	r1, [r0], #4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:571
                str r1, [r0], #PORTx_PCRn_OFFSET
 776:	f840 1b04 	str.w	r1, [r0], #4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:572
                str r1, [r0], #PORTx_PCRn_OFFSET
 77a:	f840 1b04 	str.w	r1, [r0], #4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:573
                str r1, [r0], #PORTx_PCRn_OFFSET
 77e:	f840 1b04 	str.w	r1, [r0], #4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:574
                str r1, [r0], #PORTx_PCRn_OFFSET
 782:	f840 1b04 	str.w	r1, [r0], #4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:575
                str r1, [r0], #PORTx_PCRn_OFFSET
 786:	f840 1b04 	str.w	r1, [r0], #4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:576
                str r1, [r0], #PORTx_PCRn_OFFSET
 78a:	f840 1b04 	str.w	r1, [r0], #4
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:577
                str r1, [r0]
 78e:	6001      	str	r1, [r0, #0]
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:579

                pop {pc}                                 /* Return to Main, Initialization finished*/
 790:	bd00      	pop	{pc}
$d():
 792:	0000      	.short	0x0000
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:106
                .section .text
main:
				bl IOShieldIni          /*  Initialize the FDRM Board for K22F */
				bl BIOOpen              /*  Initialize serial port  */

				ldr r6, =UserPrompt
 794:	00000d2c 	.word	0x00000d2c
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:107
				ldr r5, =InvalidNotify
 798:	00000dbb 	.word	0x00000dbb
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:108
				ldr r8, =SineTable
 79c:	00000dd7 	.word	0x00000dd7
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:129


				/* Otherwise continuously read from the terminal until given a valid frequency*/
				mrs r4, apsr
				itttt eq
				ldreq r0, =UserFrequency
 7a0:	1fff0080 	.word	0x1fff0080
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:181
				/*       If Switches are all off, begin reading the Terminal           */
				mov r0, r8            /* Output question to user on screen*/
				bl BIOPutStrg


				ldr r0, =THREE
 7a4:	00000003 	.word	0x00000003
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:206
				mov r0, r4
				bl IsDigit

				cmp r4, #ZERO                   /* if user specifies one digit, calculate frequency using one digit*/
				ittte eq
				ldreq r0, =ZERO
 7a8:	00000000 	.word	0x00000000
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:207
				ldreq r6, =ONE
 7ac:	00000001 	.word	0x00000001
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:208
				ldreq r4, ='0
 7b0:	00000030 	.word	0x00000030
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:209
				ldrne r6, =TEN
 7b4:	0000000a 	.word	0x0000000a
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:273

				/*			Begin Process of creating Sine Wave                      */

				USAT r4, #SIX, r0               /* Saturate frequency to 63 Hz if not already done so for sanity's sake*/
				lsl r4, #SIX                    /* (freq x 64) */
			    ldr r3, =MILLION
 7b8:	000f4240 	.word	0x000f4240
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:289

sineloop:		ldrh r3, [r4], #TWO

                /* Check what range the value is in, pass the correct LBits value to LEDWrite */

				ldr r2, =P_TWO_FIVE             /* Is value in range of [0.00 : 0.25)? */
 7bc:	00002000 	.word	0x00002000
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:295
				cmp r3, r2
				itt lt
				ldrlt r0, =LED0
				blt call_ledwrite

				ldr r2, =P_FIVE                 /* Is value in range of [0.25 : 0.50)? */
 7c0:	00004000 	.word	0x00004000
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:298
				cmp r3, r2
				itt lt
				ldrlt r0, =LED1
 7c4:	00000002 	.word	0x00000002
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:301
				blt call_ledwrite

				ldr r2, =P_SEVEN_FIVE           /* Is value in range of [0.50 : 0.75)? */
 7c8:	00006000 	.word	0x00006000
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:304
				cmp r3, r2
				itt lt
				ldrlt r0, =LED2
 7cc:	00000004 	.word	0x00000004
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:307
				blt call_ledwrite

				ldr r2, =ONE_ZERO               /* Is value in range of [0.75 : 1.00)? */
 7d0:	00008000 	.word	0x00008000
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:310
				cmp r3, r2
				itt lt
				ldrlt r0, =LED3
 7d4:	00000008 	.word	0x00000008
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:313
				blt call_ledwrite

				ldr r2, =ONE_TWO_FIVE           /* Is value in range of [1.00 : 1.25)? */
 7d8:	0000a000 	.word	0x0000a000
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:316
				cmp r3, r2
				itt lt
				ldrlt r0, =LED4
 7dc:	00000010 	.word	0x00000010
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:319
				blt call_ledwrite

				ldr r2, =ONE_FIVE               /* Is value in range of [1.25 : 1.50)? */
 7e0:	0000c000 	.word	0x0000c000
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:322
				cmp r3, r2
				itt lt
				ldrlt r0, =LED5
 7e4:	00000020 	.word	0x00000020
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:325
				blt call_ledwrite

				ldr r2, =ONE_SEVEN_FIVE         /* Is value in range of [1.50 : 1.75)? */
 7e8:	0000e000 	.word	0x0000e000
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:328
				cmp r3, r2
				itt lt
				ldrlt r0, =LED6
 7ec:	00000040 	.word	0x00000040
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:331
				blt call_ledwrite

				ldr r0, =LED7                   /* Assume at this point that value of sine table */
 7f0:	00000080 	.word	0x00000080
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:431
                orr r0, r1                             /* Place bits for all  in r0 */

                /* Extract bits for correct GPIOx_PDOR to update correct LED(s) */
                mvn r0, r0                             /* Make value Active LOW to be used to update LED */

                ldr r2, =GPIOD_PDOR                    /* Update status of LED[2:0] on IO FDRM Shield */
 7f4:	400ff0c0 	.word	0x400ff0c0
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:438
                mov r1, r3
                bfi r1, r0, #ZERO, #FIVE
                bfi r1, r3, #ZERO, #TWO
                str r1, [r2]

                ldr r2, =GPIOB_PDOR                    /* Update status of LED[7:3] on IO FDRM Shield*/
 7f8:	400ff040 	.word	0x400ff040
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:486
 *
 * Robert Sanborn, 3/9/18
 **********************************************************************************/
SwArrayRead:    push {lr}

                ldr r3, =GPIOC_PDOR
 7fc:	400ff080 	.word	0x400ff080
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:507
 * Robert Sanborn, 3/9/18
 *****************************************************************************/
IOShieldIni:    push {lr}

                /* Initialize Clock Gate for Ports B, C, and D */
				ldr r0, =SIM_SCGC5
 800:	40048038 	.word	0x40048038
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:523
                str r3, [r1, #GPIOx_PDDR_OFFSET]

                /* Initialize PORT B Data Direction Register for LED[7:3] to make Outputs*/
                ldr r1, =GPIOB_PDOR
                ldr r3, [r1, #GPIOx_PDDR_OFFSET]
                ldr r2, =BM_LEDOUT_GPIOB_PDDR        /* Bit Mask for initializing LED[7:3] to make Outputs*/
 804:	000d0003 	.word	0x000d0003
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:531


                /* Initialize PORT C Data Direction register for Switches to become Inputs*/
                ldr r1, =GPIOC_PDOR
                ldr r3, [r1, #GPIOx_PDDR_OFFSET]
                ldr r2, =BM_SWIN_GPIOC_PDDR
 808:	fffffc03 	.word	0xfffffc03
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:553
                str r3, [r1]

				/*              Initialize PCRs for LEDs and Switches                   */

                /* Initialize Pin Control Registers for LED[2:0] on PORTD */
                ldr r0, =PORTD_PCR2
 80c:	4004c008 	.word	0x4004c008
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:554
                ldr r1, =PORT_PCR_MUX_ALT1
 810:	00000100 	.word	0x00000100
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:560
                str r1, [r0], #PORTx_PCRn_OFFSET
                str r1, [r0], #PORTx_PCRn_OFFSET
                str r1, [r0]

                /* Initialize Pin Control Registers for LED[7:3] on PORTD */
                ldr r0, =PORTB_PCR0
 814:	4004a000 	.word	0x4004a000
Z:\EE244\Lab4\Debug/../Sources/Lab4Proj.asm:568
                str r1, [r0, #OFFSET_PORTB_PCR16]
                str r1, [r0, #OFFSET_PORTB_PCR18]!
                str r1, [r0, #PORTx_PCRn_OFFSET]

  				/* Initialize Pin Control Registers for SWITCH[7:0] on PORTC    */
                ldr r0, =PORTC_PCR2
 818:	4004b008 	.word	0x4004b008

0000081c <Reset_Handler>:
Reset_Handler():
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:326
    .align 2
    .globl   Reset_Handler
    .weak    Reset_Handler
    .type    Reset_Handler, %function
Reset_Handler:
    cpsid   i               /* Mask interrupts */
 81c:	b672      	cpsid	i
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:328
#ifndef __NO_SYSTEM_INIT
    bl SystemInit
 81e:	f000 f815 	bl	84c <SystemInit>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:330
#endif
    cpsie   i               /* Unmask interrupts */
 822:	b662      	cpsie	i
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:338
 *      linker script.
 *      __etext: End of code section, i.e., begin of data sections to copy from.
 *      __data_start__/__data_end__: RAM address range that data should be
 *      copied to. Both must be aligned to 4 bytes boundary.  */

    ldr    r1, =__etext
 824:	4905      	ldr	r1, [pc, #20]	; (83c <Reset_Handler+0x20>)
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:339
    ldr    r2, =__data_start__
 826:	4a06      	ldr	r2, [pc, #24]	; (840 <Reset_Handler+0x24>)
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:340
    ldr    r3, =__data_end__
 828:	4b06      	ldr	r3, [pc, #24]	; (844 <Reset_Handler+0x28>)
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:347
#if 1
/* Here are two copies of loop implemenations. First one favors code size
 * and the second one favors performance. Default uses the first one.
 * Change to "#if 0" to use the second one */
.LC0:
    cmp     r2, r3
 82a:	429a      	cmp	r2, r3
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:348
    ittt    lt
 82c:	bfbe      	ittt	lt
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:349
    ldrlt   r0, [r1], #4
 82e:	f851 0b04 	ldrlt.w	r0, [r1], #4
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:350
    strlt   r0, [r2], #4
 832:	f842 0b04 	strlt.w	r0, [r2], #4
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:351
    blt    .LC0
 836:	e7f8      	blt.n	82a <Reset_Handler+0xe>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:386
#endif /* __STARTUP_CLEAR_BSS */

#ifndef __START
#define __START _start
#endif
    bl    __START
 838:	f7ff fe14 	bl	464 <_mainCRTStartup>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:338
 *      linker script.
 *      __etext: End of code section, i.e., begin of data sections to copy from.
 *      __data_start__/__data_end__: RAM address range that data should be
 *      copied to. Both must be aligned to 4 bytes boundary.  */

    ldr    r1, =__etext
 83c:	00000e8c 	.word	0x00000e8c
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:339
    ldr    r2, =__data_start__
 840:	1fff0000 	.word	0x1fff0000
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:340
    ldr    r3, =__data_end__
 844:	1fff0064 	.word	0x1fff0064

00000848 <ADC0_IRQHandler>:
Reserved96_IRQHandler():
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/startup_MK22F51212.S:395
    .align	1
    .thumb_func
    .weak DefaultISR
    .type DefaultISR, %function
DefaultISR:
    b	DefaultISR
 848:	f7ff bffe 	b.w	848 <ADC0_IRQHandler>

0000084c <SystemInit>:
SystemInit():
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:108

/* ----------------------------------------------------------------------------
   -- SystemInit()
   ---------------------------------------------------------------------------- */

void SystemInit (void) {
 84c:	b480      	push	{r7}
 84e:	af00      	add	r7, sp, #0
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:110
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) | (3UL << 11*2));    /* set CP10, CP11 Full Access */
 850:	4b77      	ldr	r3, [pc, #476]	; (a30 <SystemInit+0x1e4>)
 852:	4a77      	ldr	r2, [pc, #476]	; (a30 <SystemInit+0x1e4>)
 854:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 858:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 85c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:115
#endif /* ((__FPU_PRESENT == 1) && (__FPU_USED == 1)) */

#if (DISABLE_WDOG)
  /* WDOG->UNLOCK: WDOGUNLOCK=0xC520 */
  WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xC520); /* Key 1 */
 860:	4b74      	ldr	r3, [pc, #464]	; (a34 <SystemInit+0x1e8>)
 862:	f24c 5220 	movw	r2, #50464	; 0xc520
 866:	81da      	strh	r2, [r3, #14]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:117
  /* WDOG->UNLOCK: WDOGUNLOCK=0xD928 */
  WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xD928); /* Key 2 */
 868:	4b72      	ldr	r3, [pc, #456]	; (a34 <SystemInit+0x1e8>)
 86a:	f64d 1228 	movw	r2, #55592	; 0xd928
 86e:	81da      	strh	r2, [r3, #14]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:119
  /* WDOG->STCTRLH: ?=0,DISTESTWDOG=0,BYTESEL=0,TESTSEL=0,TESTWDOG=0,?=0,?=1,WAITEN=1,STOPEN=1,DBGEN=0,ALLOWUPDATE=1,WINEN=0,IRQRSTEN=0,CLKSRC=1,WDOGEN=0 */
  WDOG->STCTRLH = WDOG_STCTRLH_BYTESEL(0x00) |
 870:	4b70      	ldr	r3, [pc, #448]	; (a34 <SystemInit+0x1e8>)
 872:	f44f 72e9 	mov.w	r2, #466	; 0x1d2
 876:	801a      	strh	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:127
                 WDOG_STCTRLH_ALLOWUPDATE_MASK |
                 WDOG_STCTRLH_CLKSRC_MASK |
                 0x0100U;
#endif /* (DISABLE_WDOG) */
#ifdef CLOCK_SETUP
  if((RCM->SRS0 & RCM_SRS0_WAKEUP_MASK) != 0x00U)
 878:	4b6f      	ldr	r3, [pc, #444]	; (a38 <SystemInit+0x1ec>)
 87a:	781b      	ldrb	r3, [r3, #0]
 87c:	b2db      	uxtb	r3, r3
 87e:	f003 0301 	and.w	r3, r3, #1
 882:	2b00      	cmp	r3, #0
 884:	d00f      	beq.n	8a6 <SystemInit+0x5a>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:129
  {
    if((PMC->REGSC & PMC_REGSC_ACKISO_MASK) != 0x00U)
 886:	4b6d      	ldr	r3, [pc, #436]	; (a3c <SystemInit+0x1f0>)
 888:	789b      	ldrb	r3, [r3, #2]
 88a:	b2db      	uxtb	r3, r3
 88c:	f003 0308 	and.w	r3, r3, #8
 890:	2b00      	cmp	r3, #0
 892:	d02e      	beq.n	8f2 <SystemInit+0xa6>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:131
    {
       PMC->REGSC |= PMC_REGSC_ACKISO_MASK; /* Release hold with ACKISO:  Only has an effect if recovering from VLLSx.*/
 894:	4b69      	ldr	r3, [pc, #420]	; (a3c <SystemInit+0x1f0>)
 896:	4a69      	ldr	r2, [pc, #420]	; (a3c <SystemInit+0x1f0>)
 898:	7892      	ldrb	r2, [r2, #2]
 89a:	b2d2      	uxtb	r2, r2
 89c:	f042 0208 	orr.w	r2, r2, #8
 8a0:	b2d2      	uxtb	r2, r2
 8a2:	709a      	strb	r2, [r3, #2]
 8a4:	e025      	b.n	8f2 <SystemInit+0xa6>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:135
    }
  } else {
#ifdef SYSTEM_RTC_CR_VALUE
    SIM_SCGC6 |= SIM_SCGC6_RTC_MASK;
 8a6:	4966      	ldr	r1, [pc, #408]	; (a40 <SystemInit+0x1f4>)
 8a8:	4b65      	ldr	r3, [pc, #404]	; (a40 <SystemInit+0x1f4>)
 8aa:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
 8ae:	331c      	adds	r3, #28
 8b0:	681b      	ldr	r3, [r3, #0]
 8b2:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
 8b6:	f501 5381 	add.w	r3, r1, #4128	; 0x1020
 8ba:	331c      	adds	r3, #28
 8bc:	601a      	str	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:136
    if ((RTC_CR & RTC_CR_OSCE_MASK) == 0x00U) { /* Only if the OSCILLATOR is not already enabled */
 8be:	4b61      	ldr	r3, [pc, #388]	; (a44 <SystemInit+0x1f8>)
 8c0:	691b      	ldr	r3, [r3, #16]
 8c2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8c6:	2b00      	cmp	r3, #0
 8c8:	d113      	bne.n	8f2 <SystemInit+0xa6>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:137
      RTC_CR = (uint32_t)((RTC_CR & (uint32_t)~(uint32_t)(RTC_CR_SC2P_MASK | RTC_CR_SC4P_MASK | RTC_CR_SC8P_MASK | RTC_CR_SC16P_MASK)) | (uint32_t)SYSTEM_RTC_CR_VALUE);
 8ca:	4b5e      	ldr	r3, [pc, #376]	; (a44 <SystemInit+0x1f8>)
 8cc:	4a5d      	ldr	r2, [pc, #372]	; (a44 <SystemInit+0x1f8>)
 8ce:	6912      	ldr	r2, [r2, #16]
 8d0:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
 8d4:	f442 7240 	orr.w	r2, r2, #768	; 0x300
 8d8:	611a      	str	r2, [r3, #16]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:138
      RTC_CR |= (uint32_t)RTC_CR_OSCE_MASK;
 8da:	4b5a      	ldr	r3, [pc, #360]	; (a44 <SystemInit+0x1f8>)
 8dc:	4a59      	ldr	r2, [pc, #356]	; (a44 <SystemInit+0x1f8>)
 8de:	6912      	ldr	r2, [r2, #16]
 8e0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8e4:	611a      	str	r2, [r3, #16]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:139
      RTC_CR &= (uint32_t)~(uint32_t)RTC_CR_CLKO_MASK;
 8e6:	4b57      	ldr	r3, [pc, #348]	; (a44 <SystemInit+0x1f8>)
 8e8:	4a56      	ldr	r2, [pc, #344]	; (a44 <SystemInit+0x1f8>)
 8ea:	6912      	ldr	r2, [r2, #16]
 8ec:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8f0:	611a      	str	r2, [r3, #16]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:146
#endif
  }

  /* Power mode protection initialization */
#ifdef SYSTEM_SMC_PMPROT_VALUE
  SMC->PMPROT = SYSTEM_SMC_PMPROT_VALUE;
 8f2:	4b55      	ldr	r3, [pc, #340]	; (a48 <SystemInit+0x1fc>)
 8f4:	22aa      	movs	r2, #170	; 0xaa
 8f6:	701a      	strb	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:151
#endif

  /* High speed run mode enable */
#if (((SYSTEM_SMC_PMCTRL_VALUE) & SMC_PMCTRL_RUNM_MASK) == (0x03U << SMC_PMCTRL_RUNM_SHIFT))
  SMC->PMCTRL = (uint8_t)((SYSTEM_SMC_PMCTRL_VALUE) & (SMC_PMCTRL_RUNM_MASK)); /* Enable HSRUN mode */
 8f8:	4b53      	ldr	r3, [pc, #332]	; (a48 <SystemInit+0x1fc>)
 8fa:	2260      	movs	r2, #96	; 0x60
 8fc:	705a      	strb	r2, [r3, #1]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:152
  while(SMC->PMSTAT != 0x80U) {        /* Wait until the system is in HSRUN mode */
 8fe:	bf00      	nop
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:152 (discriminator 1)
 900:	4b51      	ldr	r3, [pc, #324]	; (a48 <SystemInit+0x1fc>)
 902:	78db      	ldrb	r3, [r3, #3]
 904:	b2db      	uxtb	r3, r3
 906:	2b80      	cmp	r3, #128	; 0x80
 908:	d1fa      	bne.n	900 <SystemInit+0xb4>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:175
#if defined(SLOW_TRIM_ADDRESS)
  }
  #endif /* defined(SLOW_TRIM_ADDRESS) */

  /* Set system prescalers and clock sources */
  SIM->CLKDIV1 = SYSTEM_SIM_CLKDIV1_VALUE; /* Set system prescalers */
 90a:	4b4d      	ldr	r3, [pc, #308]	; (a40 <SystemInit+0x1f4>)
 90c:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
 910:	3304      	adds	r3, #4
 912:	f04f 728a 	mov.w	r2, #18087936	; 0x1140000
 916:	601a      	str	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:176
  SIM->SOPT1 = ((SIM->SOPT1) & (uint32_t)(~(SIM_SOPT1_OSC32KSEL_MASK))) | ((SYSTEM_SIM_SOPT1_VALUE) & (SIM_SOPT1_OSC32KSEL_MASK)); /* Set 32 kHz clock source (ERCLK32K) */
 918:	4b49      	ldr	r3, [pc, #292]	; (a40 <SystemInit+0x1f4>)
 91a:	4a49      	ldr	r2, [pc, #292]	; (a40 <SystemInit+0x1f4>)
 91c:	6812      	ldr	r2, [r2, #0]
 91e:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 922:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 926:	601a      	str	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:177
  SIM->SOPT2 = ((SIM->SOPT2) & (uint32_t)(~(SIM_SOPT2_PLLFLLSEL_MASK))) | ((SYSTEM_SIM_SOPT2_VALUE) & (SIM_SOPT2_PLLFLLSEL_MASK)); /* Selects the high frequency clock for various peripheral clocking options. */
 928:	4945      	ldr	r1, [pc, #276]	; (a40 <SystemInit+0x1f4>)
 92a:	4b45      	ldr	r3, [pc, #276]	; (a40 <SystemInit+0x1f4>)
 92c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 930:	3304      	adds	r3, #4
 932:	681b      	ldr	r3, [r3, #0]
 934:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 938:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 93c:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 940:	3304      	adds	r3, #4
 942:	601a      	str	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:213

#else /* MCG_MODE */
  /* Set MCG and OSC */
#if  (((SYSTEM_OSC_CR_VALUE) & OSC_CR_ERCLKEN_MASK) != 0x00U) || (((SYSTEM_MCG_C7_VALUE) & MCG_C7_OSCSEL_MASK) == 0x00U)
  /* SIM_SCGC5: PORTA=1 */
  SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
 944:	493e      	ldr	r1, [pc, #248]	; (a40 <SystemInit+0x1f4>)
 946:	4b3e      	ldr	r3, [pc, #248]	; (a40 <SystemInit+0x1f4>)
 948:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
 94c:	3318      	adds	r3, #24
 94e:	681b      	ldr	r3, [r3, #0]
 950:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 954:	f501 5381 	add.w	r3, r1, #4128	; 0x1020
 958:	3318      	adds	r3, #24
 95a:	601a      	str	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:215
  /* PORTA_PCR18: ISF=0,MUX=0 */
  PORTA_PCR18 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
 95c:	4a3b      	ldr	r2, [pc, #236]	; (a4c <SystemInit+0x200>)
 95e:	4b3b      	ldr	r3, [pc, #236]	; (a4c <SystemInit+0x200>)
 960:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 962:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 966:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 96a:	6493      	str	r3, [r2, #72]	; 0x48
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:218
  if (((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS_MASK) != 0x00U) {
  /* PORTA_PCR19: ISF=0,MUX=0 */
  PORTA_PCR19 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
 96c:	4a37      	ldr	r2, [pc, #220]	; (a4c <SystemInit+0x200>)
 96e:	4b37      	ldr	r3, [pc, #220]	; (a4c <SystemInit+0x200>)
 970:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 972:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 976:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 97a:	64d3      	str	r3, [r2, #76]	; 0x4c
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:221
  }
#endif
  MCG->SC = SYSTEM_MCG_SC_VALUE;       /* Set SC (fast clock internal reference divider) */
 97c:	4b34      	ldr	r3, [pc, #208]	; (a50 <SystemInit+0x204>)
 97e:	2200      	movs	r2, #0
 980:	721a      	strb	r2, [r3, #8]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:222
  MCG->C2 = (MCG->C2 & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (SYSTEM_MCG_C2_VALUE & (uint8_t)(~(MCG_C2_LP_MASK))); /* Set C2 (freq. range, ext. and int. reference selection etc. excluding trim bits; low power bit is set later) */
 982:	4b33      	ldr	r3, [pc, #204]	; (a50 <SystemInit+0x204>)
 984:	4a32      	ldr	r2, [pc, #200]	; (a50 <SystemInit+0x204>)
 986:	7852      	ldrb	r2, [r2, #1]
 988:	b2d2      	uxtb	r2, r2
 98a:	f022 0264 	bic.w	r2, r2, #100	; 0x64
 98e:	b2d2      	uxtb	r2, r2
 990:	f042 0224 	orr.w	r2, r2, #36	; 0x24
 994:	b2d2      	uxtb	r2, r2
 996:	705a      	strb	r2, [r3, #1]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:223
  OSC->CR = SYSTEM_OSC_CR_VALUE;       /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
 998:	4b2e      	ldr	r3, [pc, #184]	; (a54 <SystemInit+0x208>)
 99a:	2280      	movs	r2, #128	; 0x80
 99c:	701a      	strb	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:224
  MCG->C7 = SYSTEM_MCG_C7_VALUE;       /* Set C7 (OSC Clock Select) */
 99e:	4b2c      	ldr	r3, [pc, #176]	; (a50 <SystemInit+0x204>)
 9a0:	2200      	movs	r2, #0
 9a2:	731a      	strb	r2, [r3, #12]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:226
  #if (MCG_MODE == MCG_MODE_PEE)
  MCG->C1 = (SYSTEM_MCG_C1_VALUE) | MCG_C1_CLKS(0x02); /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) - PBE mode*/
 9a4:	4b2a      	ldr	r3, [pc, #168]	; (a50 <SystemInit+0x204>)
 9a6:	229a      	movs	r2, #154	; 0x9a
 9a8:	701a      	strb	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:231
  #else
  MCG->C1 = SYSTEM_MCG_C1_VALUE;       /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
  #endif
  if ((((SYSTEM_MCG_C2_VALUE) & MCG_C2_EREFS_MASK) != 0x00U) && (((SYSTEM_MCG_C7_VALUE) & MCG_C7_OSCSEL_MASK) == 0x00U)) {
    while((MCG->S & MCG_S_OSCINIT0_MASK) == 0x00U) { /* Check that the oscillator is running */
 9aa:	bf00      	nop
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:231 (discriminator 1)
 9ac:	4b28      	ldr	r3, [pc, #160]	; (a50 <SystemInit+0x204>)
 9ae:	799b      	ldrb	r3, [r3, #6]
 9b0:	b2db      	uxtb	r3, r3
 9b2:	f003 0302 	and.w	r3, r3, #2
 9b6:	2b00      	cmp	r3, #0
 9b8:	d0f8      	beq.n	9ac <SystemInit+0x160>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:239
  /* Check that the source of the FLL reference clock is the requested one. */
  if (((SYSTEM_MCG_C1_VALUE) & MCG_C1_IREFS_MASK) != 0x00U) {
    while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) {
    }
  } else {
    while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) {
 9ba:	bf00      	nop
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:239 (discriminator 1)
 9bc:	4b24      	ldr	r3, [pc, #144]	; (a50 <SystemInit+0x204>)
 9be:	799b      	ldrb	r3, [r3, #6]
 9c0:	b2db      	uxtb	r3, r3
 9c2:	f003 0310 	and.w	r3, r3, #16
 9c6:	2b00      	cmp	r3, #0
 9c8:	d1f8      	bne.n	9bc <SystemInit+0x170>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:242
    }
  }
  MCG->C4 = ((SYSTEM_MCG_C4_VALUE)  & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG->C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
 9ca:	4b21      	ldr	r3, [pc, #132]	; (a50 <SystemInit+0x204>)
 9cc:	4a20      	ldr	r2, [pc, #128]	; (a50 <SystemInit+0x204>)
 9ce:	78d2      	ldrb	r2, [r2, #3]
 9d0:	b2d2      	uxtb	r2, r2
 9d2:	f002 021f 	and.w	r2, r2, #31
 9d6:	b2d2      	uxtb	r2, r2
 9d8:	70da      	strb	r2, [r3, #3]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:248
#endif /* MCG_MODE */

  /* Common for all MCG modes */

  /* PLL clock can be used to generate clock for some devices regardless of clock generator (MCGOUTCLK) mode. */
  MCG->C5 = (SYSTEM_MCG_C5_VALUE) & (uint8_t)(~(MCG_C5_PLLCLKEN0_MASK)); /* Set C5 (PLL settings, PLL reference divider etc.) */
 9da:	4b1d      	ldr	r3, [pc, #116]	; (a50 <SystemInit+0x204>)
 9dc:	2201      	movs	r2, #1
 9de:	711a      	strb	r2, [r3, #4]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:249
  MCG->C6 = (SYSTEM_MCG_C6_VALUE) & (uint8_t)~(MCG_C6_PLLS_MASK); /* Set C6 (PLL select, VCO divider etc.) */
 9e0:	4b1b      	ldr	r3, [pc, #108]	; (a50 <SystemInit+0x204>)
 9e2:	2206      	movs	r2, #6
 9e4:	715a      	strb	r2, [r3, #5]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:258
  /* BLPE, PEE and PBE MCG mode specific */

#if (MCG_MODE == MCG_MODE_BLPE)
  MCG->C2 |= (MCG_C2_LP_MASK);         /* Disable FLL and PLL in bypass mode */
#elif ((MCG_MODE == MCG_MODE_PBE) || (MCG_MODE == MCG_MODE_PEE))
  MCG->C6 |= (MCG_C6_PLLS_MASK);       /* Set C6 (PLL select, VCO divider etc.) */
 9e6:	4b1a      	ldr	r3, [pc, #104]	; (a50 <SystemInit+0x204>)
 9e8:	4a19      	ldr	r2, [pc, #100]	; (a50 <SystemInit+0x204>)
 9ea:	7952      	ldrb	r2, [r2, #5]
 9ec:	b2d2      	uxtb	r2, r2
 9ee:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 9f2:	b2d2      	uxtb	r2, r2
 9f4:	715a      	strb	r2, [r3, #5]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:259
  while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until PLL is locked*/
 9f6:	bf00      	nop
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:259 (discriminator 1)
 9f8:	4b15      	ldr	r3, [pc, #84]	; (a50 <SystemInit+0x204>)
 9fa:	799b      	ldrb	r3, [r3, #6]
 9fc:	b2db      	uxtb	r3, r3
 9fe:	f003 0340 	and.w	r3, r3, #64	; 0x40
 a02:	2b00      	cmp	r3, #0
 a04:	d0f8      	beq.n	9f8 <SystemInit+0x1ac>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:262
  }
  #if (MCG_MODE == MCG_MODE_PEE)
  MCG->C1 &= (uint8_t)~(MCG_C1_CLKS_MASK);
 a06:	4b12      	ldr	r3, [pc, #72]	; (a50 <SystemInit+0x204>)
 a08:	4a11      	ldr	r2, [pc, #68]	; (a50 <SystemInit+0x204>)
 a0a:	7812      	ldrb	r2, [r2, #0]
 a0c:	b2d2      	uxtb	r2, r2
 a0e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 a12:	b2d2      	uxtb	r2, r2
 a14:	701a      	strb	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:285
  }
#elif ((MCG_MODE == MCG_MODE_FBE) || (MCG_MODE == MCG_MODE_PBE) || (MCG_MODE == MCG_MODE_BLPE))
  while((MCG->S & MCG_S_CLKST_MASK) != 0x08U) { /* Wait until external reference clock is selected as MCG output */
  }
#elif (MCG_MODE == MCG_MODE_PEE)
  while((MCG->S & MCG_S_CLKST_MASK) != 0x0CU) { /* Wait until output of the PLL is selected */
 a16:	bf00      	nop
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:285 (discriminator 1)
 a18:	4b0d      	ldr	r3, [pc, #52]	; (a50 <SystemInit+0x204>)
 a1a:	799b      	ldrb	r3, [r3, #6]
 a1c:	b2db      	uxtb	r3, r3
 a1e:	f003 030c 	and.w	r3, r3, #12
 a22:	2b0c      	cmp	r3, #12
 a24:	d1f8      	bne.n	a18 <SystemInit+0x1cc>
Z:\EE244\Lab4\Debug/../Project_Settings/Startup_Code/system_MK22F51212.c:303
  /* PLL loss of lock interrupt request initialization */
  if (((SYSTEM_MCG_C6_VALUE) & MCG_C6_LOLIE0_MASK) != 0U) {
    NVIC_EnableIRQ(MCG_IRQn);          /* Enable PLL loss of lock interrupt request */
  }
#endif
}
 a26:	46bd      	mov	sp, r7
 a28:	f85d 7b04 	ldr.w	r7, [sp], #4
 a2c:	4770      	bx	lr
 a2e:	bf00      	nop
 a30:	e000ed00 	.word	0xe000ed00
 a34:	40052000 	.word	0x40052000
 a38:	4007f000 	.word	0x4007f000
 a3c:	4007d000 	.word	0x4007d000
 a40:	40047000 	.word	0x40047000
 a44:	4003d000 	.word	0x4003d000
 a48:	4007e000 	.word	0x4007e000
 a4c:	40049000 	.word	0x40049000
 a50:	40064000 	.word	0x40064000
 a54:	40065000 	.word	0x40065000

00000a58 <BIOOpen>:
BIOOpen():
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:45
static INT8U bioHtoB(INT8C c);
/********************************************************************
* BIOOpen() - Initialization routine for BasicIO()
*    MCU: K22F, UART1 configured for debugger USB.
********************************************************************/
void BIOOpen(void){
 a58:	b480      	push	{r7}
 a5a:	af00      	add	r7, sp, #0
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:46
	SIM_SCGC5 |= SIM_SCGC5_PORTE(1); 	/* Enable clock gate for PORTE */
 a5c:	491e      	ldr	r1, [pc, #120]	; (ad8 <BIOOpen+0x80>)
 a5e:	4b1e      	ldr	r3, [pc, #120]	; (ad8 <BIOOpen+0x80>)
 a60:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
 a64:	3318      	adds	r3, #24
 a66:	681b      	ldr	r3, [r3, #0]
 a68:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 a6c:	f501 5381 	add.w	r3, r1, #4128	; 0x1020
 a70:	3318      	adds	r3, #24
 a72:	601a      	str	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:47
    SIM_SCGC4 |= SIM_SCGC4_UART1(1); 	//enables UART1 clock (120MHz)
 a74:	4918      	ldr	r1, [pc, #96]	; (ad8 <BIOOpen+0x80>)
 a76:	4b18      	ldr	r3, [pc, #96]	; (ad8 <BIOOpen+0x80>)
 a78:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
 a7c:	3314      	adds	r3, #20
 a7e:	681b      	ldr	r3, [r3, #0]
 a80:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
 a84:	f501 5381 	add.w	r3, r1, #4128	; 0x1020
 a88:	3314      	adds	r3, #20
 a8a:	601a      	str	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:49

	PORTE_PCR0 = (0|PORT_PCR_MUX(3));    //ties peripherals to mux address
 a8c:	4b13      	ldr	r3, [pc, #76]	; (adc <BIOOpen+0x84>)
 a8e:	f44f 7240 	mov.w	r2, #768	; 0x300
 a92:	601a      	str	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:50
    PORTE_PCR1 = (0|PORT_PCR_MUX(3));
 a94:	4b11      	ldr	r3, [pc, #68]	; (adc <BIOOpen+0x84>)
 a96:	f44f 7240 	mov.w	r2, #768	; 0x300
 a9a:	605a      	str	r2, [r3, #4]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:51
    UART1_BDH = 0x03;           		//sets clock divisor for 9600Hz Baud Rate
 a9c:	4b10      	ldr	r3, [pc, #64]	; (ae0 <BIOOpen+0x88>)
 a9e:	2203      	movs	r2, #3
 aa0:	701a      	strb	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:52
    UART1_BDL = 0x0d;           		//   120M / (16*781.25) = 9600
 aa2:	4b0f      	ldr	r3, [pc, #60]	; (ae0 <BIOOpen+0x88>)
 aa4:	220d      	movs	r2, #13
 aa6:	705a      	strb	r2, [r3, #1]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:53
    UART1_C2 |= UART_C2_TE_MASK;    	//enables transmission
 aa8:	4b0d      	ldr	r3, [pc, #52]	; (ae0 <BIOOpen+0x88>)
 aaa:	4a0d      	ldr	r2, [pc, #52]	; (ae0 <BIOOpen+0x88>)
 aac:	78d2      	ldrb	r2, [r2, #3]
 aae:	b2d2      	uxtb	r2, r2
 ab0:	f042 0208 	orr.w	r2, r2, #8
 ab4:	b2d2      	uxtb	r2, r2
 ab6:	70da      	strb	r2, [r3, #3]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:54
    UART1_C2 |= UART_C2_RE_MASK;    	//enables receive
 ab8:	4b09      	ldr	r3, [pc, #36]	; (ae0 <BIOOpen+0x88>)
 aba:	4a09      	ldr	r2, [pc, #36]	; (ae0 <BIOOpen+0x88>)
 abc:	78d2      	ldrb	r2, [r2, #3]
 abe:	b2d2      	uxtb	r2, r2
 ac0:	f042 0204 	orr.w	r2, r2, #4
 ac4:	b2d2      	uxtb	r2, r2
 ac6:	70da      	strb	r2, [r3, #3]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:55
    UART1_C4 = 8;                		//sets the .25 of divisor
 ac8:	4b05      	ldr	r3, [pc, #20]	; (ae0 <BIOOpen+0x88>)
 aca:	2208      	movs	r2, #8
 acc:	729a      	strb	r2, [r3, #10]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:56
}
 ace:	46bd      	mov	sp, r7
 ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
 ad4:	4770      	bx	lr
 ad6:	bf00      	nop
 ad8:	40047000 	.word	0x40047000
 adc:	4004d000 	.word	0x4004d000
 ae0:	4006b000 	.word	0x4006b000

00000ae4 <BIORead>:
BIORead():
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:63
/********************************************************************
* BIORead() - Checks for a character received
*    MCU: K22, UART1
*    return: ASCII character received or 0 if no character received
********************************************************************/
INT8C BIORead(void){
 ae4:	b480      	push	{r7}
 ae6:	b083      	sub	sp, #12
 ae8:	af00      	add	r7, sp, #0
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:65
    INT8C c;
    if (UART1_S1 & UART_S1_RDRF_MASK){   //check if char received
 aea:	4b0b      	ldr	r3, [pc, #44]	; (b18 <BIORead+0x34>)
 aec:	791b      	ldrb	r3, [r3, #4]
 aee:	b2db      	uxtb	r3, r3
 af0:	f003 0320 	and.w	r3, r3, #32
 af4:	2b00      	cmp	r3, #0
 af6:	d004      	beq.n	b02 <BIORead+0x1e>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:66
        c = UART1_D;
 af8:	4b07      	ldr	r3, [pc, #28]	; (b18 <BIORead+0x34>)
 afa:	79db      	ldrb	r3, [r3, #7]
 afc:	b2db      	uxtb	r3, r3
 afe:	71fb      	strb	r3, [r7, #7]
 b00:	e001      	b.n	b06 <BIORead+0x22>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:68
    }else{
        c = 0;                           //If not return 0
 b02:	2300      	movs	r3, #0
 b04:	71fb      	strb	r3, [r7, #7]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:70
    }
    return (c);
 b06:	79fb      	ldrb	r3, [r7, #7]
 b08:	b25b      	sxtb	r3, r3
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:71
}
 b0a:	4618      	mov	r0, r3
 b0c:	370c      	adds	r7, #12
 b0e:	46bd      	mov	sp, r7
 b10:	f85d 7b04 	ldr.w	r7, [sp], #4
 b14:	4770      	bx	lr
 b16:	bf00      	nop
 b18:	4006b000 	.word	0x4006b000

00000b1c <BIOGetChar>:
BIOGetChar():
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:76
/********************************************************************
* BIOGetChar() - Blocks until character is received
*    return: INT8C ASCII character
********************************************************************/
INT8C BIOGetChar(void){
 b1c:	b580      	push	{r7, lr}
 b1e:	b082      	sub	sp, #8
 b20:	af00      	add	r7, sp, #0
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:79 (discriminator 1)
    INT8C c;
    do{
        c = BIORead();
 b22:	f7ff ffdf 	bl	ae4 <BIORead>
 b26:	4603      	mov	r3, r0
 b28:	71fb      	strb	r3, [r7, #7]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:80 (discriminator 1)
    }while(c == 0);
 b2a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 b2e:	2b00      	cmp	r3, #0
 b30:	d0f7      	beq.n	b22 <BIOGetChar+0x6>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:81
    return c;
 b32:	79fb      	ldrb	r3, [r7, #7]
 b34:	b25b      	sxtb	r3, r3
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:82
}
 b36:	4618      	mov	r0, r3
 b38:	3708      	adds	r7, #8
 b3a:	46bd      	mov	sp, r7
 b3c:	bd80      	pop	{r7, pc}
 b3e:	bf00      	nop

00000b40 <BIOWrite>:
BIOWrite():
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:90
* BIOWrite() - Sends an ASCII character
*              Blocks as much as one character time
*    MCU: K22, UART1
*    parameter: c is the ASCII character to be sent
********************************************************************/
void BIOWrite(INT8C c){
 b40:	b480      	push	{r7}
 b42:	b083      	sub	sp, #12
 b44:	af00      	add	r7, sp, #0
 b46:	4603      	mov	r3, r0
 b48:	71fb      	strb	r3, [r7, #7]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:91
    while (!(UART1_S1 & UART_S1_TDRE_MASK)){} //waits until transmission
 b4a:	bf00      	nop
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:91 (discriminator 1)
 b4c:	4b07      	ldr	r3, [pc, #28]	; (b6c <BIOWrite+0x2c>)
 b4e:	791b      	ldrb	r3, [r3, #4]
 b50:	b2db      	uxtb	r3, r3
 b52:	b2db      	uxtb	r3, r3
 b54:	b25b      	sxtb	r3, r3
 b56:	2b00      	cmp	r3, #0
 b58:	daf8      	bge.n	b4c <BIOWrite+0xc>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:92
    UART1_D = c;                             //is ready
 b5a:	4b04      	ldr	r3, [pc, #16]	; (b6c <BIOWrite+0x2c>)
 b5c:	79fa      	ldrb	r2, [r7, #7]
 b5e:	71da      	strb	r2, [r3, #7]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:93
}
 b60:	370c      	adds	r7, #12
 b62:	46bd      	mov	sp, r7
 b64:	f85d 7b04 	ldr.w	r7, [sp], #4
 b68:	4770      	bx	lr
 b6a:	bf00      	nop
 b6c:	4006b000 	.word	0x4006b000

00000b70 <BIOPutStrg>:
BIOPutStrg():
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:99

/********************************************************************
* BIOPutStrg() - Writes a string to monitor
*    parameter: strg is a pointer to the ASCII string
********************************************************************/
void BIOPutStrg(const INT8C *strg){
 b70:	b580      	push	{r7, lr}
 b72:	b084      	sub	sp, #16
 b74:	af00      	add	r7, sp, #0
 b76:	6078      	str	r0, [r7, #4]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:100
    const INT8C *strgptr = strg;
 b78:	687b      	ldr	r3, [r7, #4]
 b7a:	60fb      	str	r3, [r7, #12]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:101
    while (*strgptr != 0){              //until a null is reached
 b7c:	e008      	b.n	b90 <BIOPutStrg+0x20>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:102
        BIOWrite(*strgptr);
 b7e:	68fb      	ldr	r3, [r7, #12]
 b80:	781b      	ldrb	r3, [r3, #0]
 b82:	b25b      	sxtb	r3, r3
 b84:	4618      	mov	r0, r3
 b86:	f7ff ffdb 	bl	b40 <BIOWrite>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:103
        strgptr++;
 b8a:	68fb      	ldr	r3, [r7, #12]
 b8c:	3301      	adds	r3, #1
 b8e:	60fb      	str	r3, [r7, #12]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:101 (discriminator 1)
* BIOPutStrg() - Writes a string to monitor
*    parameter: strg is a pointer to the ASCII string
********************************************************************/
void BIOPutStrg(const INT8C *strg){
    const INT8C *strgptr = strg;
    while (*strgptr != 0){              //until a null is reached
 b90:	68fb      	ldr	r3, [r7, #12]
 b92:	781b      	ldrb	r3, [r3, #0]
 b94:	2b00      	cmp	r3, #0
 b96:	d1f2      	bne.n	b7e <BIOPutStrg+0xe>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:105
        BIOWrite(*strgptr);
        strgptr++;
    }
}
 b98:	3710      	adds	r7, #16
 b9a:	46bd      	mov	sp, r7
 b9c:	bd80      	pop	{r7, pc}
 b9e:	bf00      	nop

00000ba0 <BIOGetStrg>:
BIOGetStrg():
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:188
* Return value: 0 -> if ended with CR
*               1 -> if strglen exceeded.
* Arguments: *strg is a pointer to the string array
*            strglen is the max string length, includes CR/NULL.
********************************************************************/
INT8U BIOGetStrg(INT8U strglen,const INT8C *strg){
 ba0:	b580      	push	{r7, lr}
 ba2:	b086      	sub	sp, #24
 ba4:	af00      	add	r7, sp, #0
 ba6:	4603      	mov	r3, r0
 ba8:	6039      	str	r1, [r7, #0]
 baa:	71fb      	strb	r3, [r7, #7]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:189
   INT8U charnum = 0;
 bac:	2300      	movs	r3, #0
 bae:	75fb      	strb	r3, [r7, #23]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:191
   INT8C c;
   INT8C *strgp = (INT8C *)strg;
 bb0:	683b      	ldr	r3, [r7, #0]
 bb2:	613b      	str	r3, [r7, #16]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:192
   INT8U rvalue = 1;
 bb4:	2301      	movs	r3, #1
 bb6:	73fb      	strb	r3, [r7, #15]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:193
   c = BIOGetChar();
 bb8:	f7ff ffb0 	bl	b1c <BIOGetChar>
 bbc:	4603      	mov	r3, r0
 bbe:	75bb      	strb	r3, [r7, #22]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:194
   while((c != '\r') && ((charnum <= strglen-1))){
 bc0:	e04c      	b.n	c5c <BIOGetStrg+0xbc>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:195
       if((' ' <= c) && ('~' >= c) && (charnum < (strglen-1))){
 bc2:	f997 3016 	ldrsb.w	r3, [r7, #22]
 bc6:	2b1f      	cmp	r3, #31
 bc8:	dd1b      	ble.n	c02 <BIOGetStrg+0x62>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:195 (discriminator 1)
 bca:	f997 3016 	ldrsb.w	r3, [r7, #22]
 bce:	2b7f      	cmp	r3, #127	; 0x7f
 bd0:	d017      	beq.n	c02 <BIOGetStrg+0x62>
 bd2:	7dfa      	ldrb	r2, [r7, #23]
 bd4:	79fb      	ldrb	r3, [r7, #7]
 bd6:	3b01      	subs	r3, #1
 bd8:	429a      	cmp	r2, r3
 bda:	da12      	bge.n	c02 <BIOGetStrg+0x62>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:196
           BIOWrite(c);
 bdc:	f997 3016 	ldrsb.w	r3, [r7, #22]
 be0:	4618      	mov	r0, r3
 be2:	f7ff ffad 	bl	b40 <BIOWrite>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:197
           *strgp = c;
 be6:	693b      	ldr	r3, [r7, #16]
 be8:	7dba      	ldrb	r2, [r7, #22]
 bea:	701a      	strb	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:198
           strgp++;
 bec:	693b      	ldr	r3, [r7, #16]
 bee:	3301      	adds	r3, #1
 bf0:	613b      	str	r3, [r7, #16]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:199
           charnum++;
 bf2:	7dfb      	ldrb	r3, [r7, #23]
 bf4:	3301      	adds	r3, #1
 bf6:	75fb      	strb	r3, [r7, #23]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:200
           c=BIOGetChar();
 bf8:	f7ff ff90 	bl	b1c <BIOGetChar>
 bfc:	4603      	mov	r3, r0
 bfe:	75bb      	strb	r3, [r7, #22]
 c00:	e02c      	b.n	c5c <BIOGetStrg+0xbc>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:201
       }else if((c == '\b') && (charnum <= (strglen - 1))){
 c02:	f997 3016 	ldrsb.w	r3, [r7, #22]
 c06:	2b08      	cmp	r3, #8
 c08:	d118      	bne.n	c3c <BIOGetStrg+0x9c>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:201 (discriminator 1)
 c0a:	7dfa      	ldrb	r2, [r7, #23]
 c0c:	79fb      	ldrb	r3, [r7, #7]
 c0e:	3b01      	subs	r3, #1
 c10:	429a      	cmp	r2, r3
 c12:	dc13      	bgt.n	c3c <BIOGetStrg+0x9c>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:202
           BIOWrite('\b');
 c14:	2008      	movs	r0, #8
 c16:	f7ff ff93 	bl	b40 <BIOWrite>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:203
           BIOWrite(' ');
 c1a:	2020      	movs	r0, #32
 c1c:	f7ff ff90 	bl	b40 <BIOWrite>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:204
           BIOWrite('\b');
 c20:	2008      	movs	r0, #8
 c22:	f7ff ff8d 	bl	b40 <BIOWrite>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:205
           strgp--;
 c26:	693b      	ldr	r3, [r7, #16]
 c28:	3b01      	subs	r3, #1
 c2a:	613b      	str	r3, [r7, #16]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:206
           charnum--;
 c2c:	7dfb      	ldrb	r3, [r7, #23]
 c2e:	3b01      	subs	r3, #1
 c30:	75fb      	strb	r3, [r7, #23]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:207
           c=BIOGetChar();
 c32:	f7ff ff73 	bl	b1c <BIOGetChar>
 c36:	4603      	mov	r3, r0
 c38:	75bb      	strb	r3, [r7, #22]
 c3a:	e00f      	b.n	c5c <BIOGetStrg+0xbc>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:208
       }else if((' ' <= c) && ('~' >= c) && (charnum <= (strglen - 1))){
 c3c:	f997 3016 	ldrsb.w	r3, [r7, #22]
 c40:	2b1f      	cmp	r3, #31
 c42:	dd0b      	ble.n	c5c <BIOGetStrg+0xbc>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:208 (discriminator 1)
 c44:	f997 3016 	ldrsb.w	r3, [r7, #22]
 c48:	2b7f      	cmp	r3, #127	; 0x7f
 c4a:	d007      	beq.n	c5c <BIOGetStrg+0xbc>
 c4c:	7dfa      	ldrb	r2, [r7, #23]
 c4e:	79fb      	ldrb	r3, [r7, #7]
 c50:	3b01      	subs	r3, #1
 c52:	429a      	cmp	r2, r3
 c54:	dc02      	bgt.n	c5c <BIOGetStrg+0xbc>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:209
           charnum++;
 c56:	7dfb      	ldrb	r3, [r7, #23]
 c58:	3301      	adds	r3, #1
 c5a:	75fb      	strb	r3, [r7, #23]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:194 (discriminator 1)
   INT8U charnum = 0;
   INT8C c;
   INT8C *strgp = (INT8C *)strg;
   INT8U rvalue = 1;
   c = BIOGetChar();
   while((c != '\r') && ((charnum <= strglen-1))){
 c5c:	f997 3016 	ldrsb.w	r3, [r7, #22]
 c60:	2b0d      	cmp	r3, #13
 c62:	d004      	beq.n	c6e <BIOGetStrg+0xce>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:194 (discriminator 2)
 c64:	7dfa      	ldrb	r2, [r7, #23]
 c66:	79fb      	ldrb	r3, [r7, #7]
 c68:	3b01      	subs	r3, #1
 c6a:	429a      	cmp	r2, r3
 c6c:	dda9      	ble.n	bc2 <BIOGetStrg+0x22>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:213
       }else if((' ' <= c) && ('~' >= c) && (charnum <= (strglen - 1))){
           charnum++;
       }else{ /*non-printable character - ignore */
       }
   }
   BIOOutCRLF();
 c6e:	f000 f811 	bl	c94 <BIOOutCRLF>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:214
   *strgp = 0x00;
 c72:	693b      	ldr	r3, [r7, #16]
 c74:	2200      	movs	r2, #0
 c76:	701a      	strb	r2, [r3, #0]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:215
   if(c == '\r'){
 c78:	f997 3016 	ldrsb.w	r3, [r7, #22]
 c7c:	2b0d      	cmp	r3, #13
 c7e:	d102      	bne.n	c86 <BIOGetStrg+0xe6>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:216
       rvalue = 0;
 c80:	2300      	movs	r3, #0
 c82:	73fb      	strb	r3, [r7, #15]
 c84:	e001      	b.n	c8a <BIOGetStrg+0xea>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:218
   }else{
       rvalue = 1;
 c86:	2301      	movs	r3, #1
 c88:	73fb      	strb	r3, [r7, #15]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:220
   }
   return rvalue;
 c8a:	7bfb      	ldrb	r3, [r7, #15]
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:221
}
 c8c:	4618      	mov	r0, r3
 c8e:	3718      	adds	r7, #24
 c90:	46bd      	mov	sp, r7
 c92:	bd80      	pop	{r7, pc}

00000c94 <BIOOutCRLF>:
BIOOutCRLF():
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:227

/********************************************************************
* BIOOutCRLF() - Outputs a carriage return and line feed.
*
********************************************************************/
extern void BIOOutCRLF(void){
 c94:	b580      	push	{r7, lr}
 c96:	af00      	add	r7, sp, #0
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:228
    BIOPutStrg("\r\n");
 c98:	4801      	ldr	r0, [pc, #4]	; (ca0 <BIOOutCRLF+0xc>)
 c9a:	f7ff ff69 	bl	b70 <BIOPutStrg>
Z:\EE244\Lab4\Debug/../Project_Settings/BasicIO_Code/BasicIO.c:229
}
 c9e:	bd80      	pop	{r7, pc}
 ca0:	00000e58 	.word	0x00000e58

00000ca4 <exit>:
exit():
 ca4:	b508      	push	{r3, lr}
 ca6:	4b07      	ldr	r3, [pc, #28]	; (cc4 <exit+0x20>)
 ca8:	4604      	mov	r4, r0
 caa:	b113      	cbz	r3, cb2 <exit+0xe>
 cac:	2100      	movs	r1, #0
 cae:	f3af 8000 	nop.w
 cb2:	4b05      	ldr	r3, [pc, #20]	; (cc8 <exit+0x24>)
 cb4:	6818      	ldr	r0, [r3, #0]
 cb6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 cb8:	b103      	cbz	r3, cbc <exit+0x18>
 cba:	4798      	blx	r3
 cbc:	4620      	mov	r0, r4
 cbe:	f000 f833 	bl	d28 <_exit>
 cc2:	bf00      	nop
 cc4:	00000000 	.word	0x00000000
 cc8:	00000e60 	.word	0x00000e60

00000ccc <__libc_init_array>:
__libc_init_array():
 ccc:	b570      	push	{r4, r5, r6, lr}
 cce:	4b0e      	ldr	r3, [pc, #56]	; (d08 <__libc_init_array+0x3c>)
 cd0:	4d0e      	ldr	r5, [pc, #56]	; (d0c <__libc_init_array+0x40>)
 cd2:	1aed      	subs	r5, r5, r3
 cd4:	10ad      	asrs	r5, r5, #2
 cd6:	2400      	movs	r4, #0
 cd8:	461e      	mov	r6, r3
 cda:	42ac      	cmp	r4, r5
 cdc:	d004      	beq.n	ce8 <__libc_init_array+0x1c>
 cde:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 ce2:	4790      	blx	r2
 ce4:	3401      	adds	r4, #1
 ce6:	e7f8      	b.n	cda <__libc_init_array+0xe>
 ce8:	f000 f8bc 	bl	e64 <_init>
 cec:	4d08      	ldr	r5, [pc, #32]	; (d10 <__libc_init_array+0x44>)
 cee:	4b09      	ldr	r3, [pc, #36]	; (d14 <__libc_init_array+0x48>)
 cf0:	1aed      	subs	r5, r5, r3
 cf2:	10ad      	asrs	r5, r5, #2
 cf4:	2400      	movs	r4, #0
 cf6:	461e      	mov	r6, r3
 cf8:	42ac      	cmp	r4, r5
 cfa:	d004      	beq.n	d06 <__libc_init_array+0x3a>
 cfc:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 d00:	4790      	blx	r2
 d02:	3401      	adds	r4, #1
 d04:	e7f8      	b.n	cf8 <__libc_init_array+0x2c>
 d06:	bd70      	pop	{r4, r5, r6, pc}
 d08:	00000e84 	.word	0x00000e84
 d0c:	00000e84 	.word	0x00000e84
 d10:	00000e88 	.word	0x00000e88
 d14:	00000e84 	.word	0x00000e84

00000d18 <memset>:
memset():
 d18:	4402      	add	r2, r0
 d1a:	4603      	mov	r3, r0
 d1c:	4293      	cmp	r3, r2
 d1e:	d002      	beq.n	d26 <memset+0xe>
 d20:	f803 1b01 	strb.w	r1, [r3], #1
 d24:	e7fa      	b.n	d1c <memset+0x4>
 d26:	4770      	bx	lr

00000d28 <_exit>:
_exit():
 d28:	e7fe      	b.n	d28 <_exit>
 d2a:	bf00      	nop

00000d2c <UserPrompt>:
UserPrompt():
 d2c:	6c6c6548 	.word	0x6c6c6548
 d30:	7355206f 	.word	0x7355206f
 d34:	202c7265 	.word	0x202c7265
 d38:	65746e65 	.word	0x65746e65
 d3c:	20612072 	.word	0x20612072
 d40:	69736564 	.word	0x69736564
 d44:	20646572 	.word	0x20646572
 d48:	71657266 	.word	0x71657266
 d4c:	636e6575 	.word	0x636e6575
 d50:	6f662079 	.word	0x6f662079
 d54:	6f792072 	.word	0x6f792072
 d58:	73207275 	.word	0x73207275
 d5c:	77656e69 	.word	0x77656e69
 d60:	2e657661 	.word	0x2e657661
 d64:	706e4920 	.word	0x706e4920
 d68:	63207475 	.word	0x63207475
 d6c:	6f206e61 	.word	0x6f206e61
 d70:	20796c6e 	.word	0x20796c6e
 d74:	61206562 	.word	0x61206562
 d78:	6f777420 	.word	0x6f777420
 d7c:	67696420 	.word	0x67696420
 d80:	6e207469 	.word	0x6e207469
 d84:	65626d75 	.word	0x65626d75
 d88:	65622072 	.word	0x65622072
 d8c:	65657774 	.word	0x65657774
 d90:	2031206e 	.word	0x2031206e
 d94:	20646e61 	.word	0x20646e61
 d98:	48203336 	.word	0x48203336
 d9c:	0d0a2e7a 	.word	0x0d0a2e7a
 da0:	656c5020 	.word	0x656c5020
 da4:	20657361 	.word	0x20657361
 da8:	65746e65 	.word	0x65746e65
 dac:	20612072 	.word	0x20612072
 db0:	71657266 	.word	0x71657266
 db4:	636e6575 	.word	0x636e6575
 db8:	2079      	.short	0x2079
	...

00000dbb <InvalidNotify>:
InvalidNotify():
 dbb:	49          	.byte	0x49
 dbc:	6c61766e 	.word	0x6c61766e
 dc0:	69206469 	.word	0x69206469
 dc4:	7475706e 	.word	0x7475706e
 dc8:	7274202c 	.word	0x7274202c
 dcc:	67612079 	.word	0x67612079
 dd0:	2e6e6961 	.word	0x2e6e6961
 dd4:	0d0a      	.short	0x0d0a
	...

00000dd7 <SineTable>:
SineTable():
 dd7:	8b          	.byte	0x8b
 dd8:	2898f88c 	.word	0x2898f88c
 ddc:	56b0fba5 	.word	0x56b0fba5
 de0:	33c71cbc 	.word	0x33c71cbc
 de4:	f2da82d1 	.word	0xf2da82d1
 de8:	e2ea6de2 	.word	0xe2ea6de2
 dec:	7df641f0 	.word	0x7df641f0
 df0:	62fd8afa 	.word	0x62fd8afa
 df4:	62ffffff 	.word	0x62ffffff
 df8:	7dfd8aff 	.word	0x7dfd8aff
 dfc:	e2f641fa 	.word	0xe2f641fa
 e00:	f2ea6df0 	.word	0xf2ea6df0
 e04:	33da82e2 	.word	0x33da82e2
 e08:	56c71cd1 	.word	0x56c71cd1
 e0c:	28b0fbbc 	.word	0x28b0fbbc
 e10:	8b98f8a5 	.word	0x8b98f8a5
 e14:	7480008c 	.word	0x7480008c
 e18:	d7670773 	.word	0xd7670773
 e1c:	a94f045a 	.word	0xa94f045a
 e20:	cc38e343 	.word	0xcc38e343
 e24:	0d257d2e 	.word	0x0d257d2e
 e28:	1d15921d 	.word	0x1d15921d
 e2c:	8209be0f 	.word	0x8209be0f
 e30:	9d027505 	.word	0x9d027505
 e34:	9d000000 	.word	0x9d000000
 e38:	82027500 	.word	0x82027500
 e3c:	1d09be05 	.word	0x1d09be05
 e40:	0d15920f 	.word	0x0d15920f
 e44:	cc257d1d 	.word	0xcc257d1d
 e48:	a938e32e 	.word	0xa938e32e
 e4c:	d74f0443 	.word	0xd74f0443
 e50:	7467075a 	.word	0x7467075a
 e54:	007fff73 	.word	0x007fff73
$d():
 e58:	00000a0d 	.word	0x00000a0d
 e5c:	00000043 	.word	0x00000043

00000e60 <_global_impure_ptr>:
 e60:	1fff0000                                ....

00000e64 <_init>:
$t():
 e64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 e66:	bf00      	nop
 e68:	bcf8      	pop	{r3, r4, r5, r6, r7}
 e6a:	bc08      	pop	{r3}
 e6c:	469e      	mov	lr, r3
 e6e:	4770      	bx	lr

00000e70 <_fini>:
 e70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 e72:	bf00      	nop
 e74:	bcf8      	pop	{r3, r4, r5, r6, r7}
 e76:	bc08      	pop	{r3}
 e78:	469e      	mov	lr, r3
 e7a:	4770      	bx	lr
